def get_bib_data
  [{"author"=>"Octave Larose, Sophie Kaleba, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"O.", "last"=>"Larose"}, {"first"=>"S.", "last"=>"Kaleba"}, {"first"=>"S.", "last"=>"Marr"}], "abstract"=>"The Truffle framework allows language implementations to reach state-of-the-art run time performance while only providing an abstract syntax tree (AST) interpreter; the AST is compiled to machine code using GraalVM’s JIT compiler. However, it can take some time before this fully optimized code is generated and executed: startup performance is consequently tightly bound to interpreter performance, therefore reducing the execution time requires us to improve interpreter performance instead of solely focusing on the JIT compiler.\r\n\r\nThrough the use of a novel technique called supernodes, we take steps towards improving the run-time performance of Truffle-based interpreters, aiming to reduce programs’ overall execution time by improving interpreter performance. We take inspiration from a well-known bytecode interpreter optimization technique: superinstructions, which reduce the instruction dispatch overhead by concatenating existing instructions. In the case of supernodes, AST nodes are merged, creating a single entity which has the same behavior as the original tree.\r\n\r\nThe main performance gain of supernodes comes from removing redundant node safety guards: for instance, regular nodes have to check the type of their input data through a type guard, even though it may have already been determined by another node which had no way of sharing this information. Supernodes avoid this problem through unifying the node contexts. Moreover, similarly to superinstructions, performance is also gained through reducing the node dispatch overhead as a result of using fewer nodes.\r\n\r\nSo far, we have been relying on the research language TruffleSOM, a minimal Smalltalk dialect implemented using Truffle, and we are focusing on the Are We Fast Yet benchmark suite, which contains both micro- and macro-benchmarks. Initial results are promising, showing up to 42% run time reduction with the addition of 20 supernodes. Moreover, there are currently no performance regressions for any of our benchmarks compared to a baseline with no supernode candidates available.\r\n\r\nHowever, node trees that yield valuable supernodes are currently detected manually, and the process of generating supernodes from them is currently not automated. In the future, we aim to develop heuristics to identify potential supernode candidates: both at parsing time through static analysis, as well as later during run time through detection of frequently called nodes that could yield performance gains should they be merged together. The supernodes would then be generated based on the code of the selected AST nodes. In addition, we aim to port our technique to more complex Truffle implementations used in the industry, such as GraalPython or TruffleRuby.", "title"=>"Less Is More: Merging AST Nodes To Optimize Interpreters", "bibtype"=>"presentation", "type"=>"", "journal"=>"", "year"=>"2022", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Workshop on Modern Language Runtimes, Ecosystems, and VMs", "interhash"=>"4ed849735696f4f3ecc82c506ae0ec07", "publisher"=>"", "series"=>"MoreVMs'22", "series_venue"=>"MoreVMs", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"mar 2022", "bibtex"=>"@presentation{Larose:2022:MoreVMs,\n  abstract = {The Truffle framework allows language implementations to reach state-of-the-art run time performance while only providing an abstract syntax tree (AST) interpreter; the AST is compiled to machine code using GraalVM’s JIT compiler. However, it can take some time before this fully optimized code is generated and executed: startup performance is consequently tightly bound to interpreter performance, therefore reducing the execution time requires us to improve interpreter performance instead of solely focusing on the JIT compiler.\r\n  \r\n  Through the use of a novel technique called supernodes, we take steps towards improving the run-time performance of Truffle-based interpreters, aiming to reduce programs’ overall execution time by improving interpreter performance. We take inspiration from a well-known bytecode interpreter optimization technique: superinstructions, which reduce the instruction dispatch overhead by concatenating existing instructions. In the case of supernodes, AST nodes are merged, creating a single entity which has the same behavior as the original tree.\r\n  \r\n  The main performance gain of supernodes comes from removing redundant node safety guards: for instance, regular nodes have to check the type of their input data through a type guard, even though it may have already been determined by another node which had no way of sharing this information. Supernodes avoid this problem through unifying the node contexts. Moreover, similarly to superinstructions, performance is also gained through reducing the node dispatch overhead as a result of using fewer nodes.\r\n  \r\n  So far, we have been relying on the research language TruffleSOM, a minimal Smalltalk dialect implemented using Truffle, and we are focusing on the Are We Fast Yet benchmark suite, which contains both micro- and macro-benchmarks. Initial results are promising, showing up to 42% run time reduction with the addition of 20 supernodes. Moreover, there are currently no performance regressions for any of our benchmarks compared to a baseline with no supernode candidates available.\r\n  \r\n  However, node trees that yield valuable supernodes are currently detected manually, and the process of generating supernodes from them is currently not automated. In the future, we aim to develop heuristics to identify potential supernode candidates: both at parsing time through static analysis, as well as later during run time through detection of frequently called nodes that could yield performance gains should they be merged together. The supernodes would then be generated based on the code of the selected AST nodes. In addition, we aim to port our technique to more complex Truffle implementations used in the industry, such as GraalPython or TruffleRuby.},\n  author = {Larose, Octave and Kaleba, Sophie and Marr, Stefan},\n  booktitle = {Workshop on Modern Language Runtimes, Ecosystems, and VMs},\n  keywords = {Graal GraalVM Interpreters MeMyPublication Optimization myown},\n  month = mar,\n  series = {MoreVMs'22},\n  title = {Less Is More: Merging AST Nodes To Optimize Interpreters},\n  year = {2022},\n  month_numeric = {3}\n}\n"}, {"author"=>"Sophie Kaleba, Octave Larose, Stefan Marr, Richard Jones", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Kaleba"}, {"first"=>"O.", "last"=>"Larose"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"R.", "last"=>"Jones"}], "abstract"=>"Web-applications are ubiquitous, from simple personal blogs to e-commerce platforms with millions of sales. Ruby-on-Rails is a popular framework implemented in Ruby that provides tools to build such web-applications. Performance is often critical in the context of large-scale web-applications; especially in dynamic languages such as Ruby that feature reflection and the use of many small methods. Such languages therefore benefit from run-time optimisations, notably through the combined use of lookup caches, splitting and inlining.\r\n\r\nTo limit their overhead, such optimisations generally rely on assumptions that do not necessarily match with the actual run- time behaviour. With Phase-based splitting, we showed that splitting can benefit from using homogeneous patterns of behaviour, called “phases” to reach better performance. In an effort to identify such phases in real-world web-applications, we thoroughly analyse the run-time call-site behaviour of Ruby programs and Ruby-on-Rails applications, running on top of TruffleRuby. This talk describes our findings and aims at guiding future research on call-site optimisation.", "title"=>"Who You Gonna Call? A Case Study about the Call-Site Behaviour in Ruby-on-Rails Applications", "bibtype"=>"presentation", "type"=>"", "journal"=>"", "year"=>"2022", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Workshop on Modern Language Runtimes, Ecosystems, and VMs", "interhash"=>"135f5e548e681f0ac0c88879a2728121", "publisher"=>"", "series"=>"MoreVMs'22", "series_venue"=>"MoreVMs", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"mar 2022", "bibtex"=>"@presentation{Kaleba:2022:MoreVMs,\n  abstract = {Web-applications are ubiquitous, from simple personal blogs to e-commerce platforms with millions of sales. Ruby-on-Rails is a popular framework implemented in Ruby that provides tools to build such web-applications. Performance is often critical in the context of large-scale web-applications; especially in dynamic languages such as Ruby that feature reflection and the use of many small methods. Such languages therefore benefit from run-time optimisations, notably through the combined use of lookup caches, splitting and inlining.\r\n  \r\n  To limit their overhead, such optimisations generally rely on assumptions that do not necessarily match with the actual run- time behaviour. With Phase-based splitting, we showed that splitting can benefit from using homogeneous patterns of behaviour, called “phases” to reach better performance. In an effort to identify such phases in real-world web-applications, we thoroughly analyse the run-time call-site behaviour of Ruby programs and Ruby-on-Rails applications, running on top of TruffleRuby. This talk describes our findings and aims at guiding future research on call-site optimisation.},\n  author = {Kaleba, Sophie and Larose, Octave and Marr, Stefan and Jones, Richard},\n  booktitle = {Workshop on Modern Language Runtimes, Ecosystems, and VMs},\n  keywords = {Behavior Benchmarking MeMyPublication Phases Ruby myown},\n  month = mar,\n  series = {MoreVMs'22},\n  title = {Who You Gonna Call? A Case Study about the Call-Site Behaviour in Ruby-on-Rails Applications},\n  venue = {MoreVMs Worshop},\n  year = {2022},\n  month_numeric = {3}\n}\n"}, {"author"=>"Stefan Marr, Octave Larose, Sophie Kaleba, Chris Seaton", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"O.", "last"=>"Larose"}, {"first"=>"S.", "last"=>"Kaleba"}, {"first"=>"C.", "last"=>"Seaton"}], "abstract"=>"Language implementation frameworks such as Truffle+Graal and RPython make the\r\npromise of state-of-the-art performance by implementing “just” the interpreter,\r\nand leaving the rest to the frameworks, which add a just-in-time compiler,\r\ngarbage collection, and various other bits “for free”. One important assumption\r\nfor these frameworks is that real systems do not spend a lot of time\r\ninterpreting user code, but reach highly-optimized compiled code quickly.\r\n\r\nUnfortunately, for large codebases with millions of lines of code, this\r\nassumption does not hold as well as for common benchmarks. A significant amount\r\nof time is spent interpreting code. This is only exacerbated by modern\r\ndevelopment approaches, which lead to, what one would assume to be long running\r\nserver applications, being updated every 30 minutes. In practice, this means\r\nfor large and actively developed codebases, interpreter performance is key.\r\n\r\nThis brings us to the question of how Truffle-based interpreters such as\r\nGraal.js, TruffleRuby, GraalPython, and TruffleSOM compare to commonly used\r\ninterpreter implementations for the same language. We will present our results\r\ncomparing these interpreters with and without just-in-time compilation on the\r\nAre We Fast Yet benchmarks, which were designed for cross-language comparison.\r\n\r\nWe will further analyze where these interpreters spend their time, and\r\nexperiment with an approach to approximate “best case” performance assuming an\r\ninterpreter could perform optimizations on the method level without requiring\r\njust-in-time compilation.\r\n\r\nBased on our observations, we will discuss a number of possible steps forward\r\nbased on the idea of supernodes, i.e., node combination, object inlining, and\r\ngenerating interpreters using Graal’s partial evaluator. All these techniques\r\nattempt to mitigate the performance cost of the “everything is a node”\r\nimplementation style of Truffle interpreters, which leads to costly run-time\r\nprogram representation and a high degree of redundancy in correctness check\r\nduring interpretation.", "title"=>"Truffle Interpreter Performance without the Holy Graal", "bibtype"=>"presentation", "type"=>"", "journal"=>"", "year"=>"2022", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"The 2022 Graal Workshop: Science, Art, Magic: Using and Developing The Graal Compiler", "interhash"=>"d6efa8011b460017d1813f75c884b9fd", "publisher"=>"", "series"=>"GraalWorshop", "series_venue"=>"GraalWorshop", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"apr 2022", "bibtex"=>"@presentation{Marr:2022:GraalWorkshop,\n  abstract = {Language implementation frameworks such as Truffle+Graal and RPython make the\r\n  promise of state-of-the-art performance by implementing “just” the interpreter,\r\n  and leaving the rest to the frameworks, which add a just-in-time compiler,\r\n  garbage collection, and various other bits “for free”. One important assumption\r\n  for these frameworks is that real systems do not spend a lot of time\r\n  interpreting user code, but reach highly-optimized compiled code quickly.\r\n  \r\n  Unfortunately, for large codebases with millions of lines of code, this\r\n  assumption does not hold as well as for common benchmarks. A significant amount\r\n  of time is spent interpreting code. This is only exacerbated by modern\r\n  development approaches, which lead to, what one would assume to be long running\r\n  server applications, being updated every 30 minutes. In practice, this means\r\n  for large and actively developed codebases, interpreter performance is key.\r\n  \r\n  This brings us to the question of how Truffle-based interpreters such as\r\n  Graal.js, TruffleRuby, GraalPython, and TruffleSOM compare to commonly used\r\n  interpreter implementations for the same language. We will present our results\r\n  comparing these interpreters with and without just-in-time compilation on the\r\n  Are We Fast Yet benchmarks, which were designed for cross-language comparison.\r\n  \r\n  We will further analyze where these interpreters spend their time, and\r\n  experiment with an approach to approximate “best case” performance assuming an\r\n  interpreter could perform optimizations on the method level without requiring\r\n  just-in-time compilation.\r\n  \r\n  Based on our observations, we will discuss a number of possible steps forward\r\n  based on the idea of supernodes, i.e., node combination, object inlining, and\r\n  generating interpreters using Graal’s partial evaluator. All these techniques\r\n  attempt to mitigate the performance cost of the “everything is a node”\r\n  implementation style of Truffle interpreters, which leads to costly run-time\r\n  program representation and a high degree of redundancy in correctness check\r\n  during interpretation.},\n  author = {Marr, Stefan and Larose, Octave and Kaleba, Sophie and Seaton, Chris},\n  booktitle = {The 2022 Graal Workshop: Science, Art, Magic: Using and Developing The Graal Compiler},\n  keywords = {GraalVM Interpreters MeMyPublication Optimization Presentation VMs myown},\n  month = apr,\n  series = {GraalWorshop},\n  title = {{Truffle Interpreter Performance without the Holy Graal}},\n  year = {2022},\n  month_numeric = {4}\n}\n"}, {"author"=>"Sophie Kaleba, Stefan Marr, Richard Jones", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Kaleba"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"R.", "last"=>"Jones"}], "title"=>"Avoiding Monomorphisation Bottlenecks with Phase-based Splitting", "bibtype"=>"presentation", "type"=>"", "journal"=>"", "year"=>"2021", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"508f180ac7ce6335df287e4ce408c15b", "publisher"=>"", "series"=>"ICOOOLPS'21", "series_venue"=>"ICOOOLPS", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"https://stefan-marr.de/downloads/icooolps21-kaleba-et-al-avoiding-monomorphisation-bottlenecks-with-phase-based-splitting.pdf", "pages"=>nil, "publication_date"=>"13 jul 2021", "bibtex"=>"@presentation{Kaleba:2021:MonoBottle,\n  author = {Kaleba, Sophie and Marr, Stefan and Jones, Richard},\n  day = {13},\n  eventtitle = {16th ACM International Workshop on Implementation, Compilation, Optimization of OO Languages, Programs and Systems},\n  keywords = {JITCompilation Lookup MeMyPublication Optimizations Phases Splitting myown},\n  month = jul,\n  pdf = {https://stefan-marr.de/downloads/icooolps21-kaleba-et-al-avoiding-monomorphisation-bottlenecks-with-phase-based-splitting.pdf},\n  series = {ICOOOLPS'21},\n  title = {{Avoiding Monomorphisation Bottlenecks with Phase-based Splitting}},\n  year = {2021},\n  month_numeric = {7}\n}\n"}, {"author"=>"Erin Greenwood-Thessman, Isaac Oscar Gariano, Richard Roberts, Stefan Marr, Michael Homer, James Noble", "author_abbr_firstname"=>[{"first"=>"E.", "last"=>"Greenwood-Thessman"}, {"first"=>"I., O.", "last"=>"Gariano"}, {"first"=>"R.", "last"=>"Roberts"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"Homer"}, {"first"=>"J.", "last"=>"Noble"}], "title"=>"Naïve Transient Cast Insertion Isn’t (That) Bad", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2021", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 16th ACM International Workshop on Implementation, Compilation, Optimization of OO Languages, Programs and Systems", "interhash"=>"46a621a755680dfb738bb1fe6ec611e0", "publisher"=>"ACM", "series"=>"ICOOOLPS'21", "series_venue"=>"ICOOOLPS", "school"=>"", "doi"=>"10.1145/3464972.3472395", "howpublished"=>"", "number"=>"", "pdf"=>"https://stefan-marr.de/downloads/icooolps21-greenwood-thessman-et-al-naive-transient-cast-insertion-isnt-that-bad.pdf", "pages"=>nil, "publication_date"=>"jul 2021", "bibtex"=>"@inproceedings{GreenwoodThessman:2021:NavieCastInsert,\n  author = {Greenwood-Thessman, Erin and Gariano, Isaac Oscar and Roberts, Richard and Marr, Stefan and Homer, Michael and Noble, James},\n  booktitle = {Proceedings of the 16th {ACM} International Workshop on Implementation, Compilation, Optimization of {OO} Languages, Programs and Systems},\n  doi = {10.1145/3464972.3472395},\n  keywords = {Evaluation Experiments Graal Grace GradualTyping MeMyPublication Optimization SOMns Truffle myown},\n  month = jul,\n  pdf = {https://stefan-marr.de/downloads/icooolps21-greenwood-thessman-et-al-naive-transient-cast-insertion-isnt-that-bad.pdf},\n  publisher = {{ACM}},\n  series = {ICOOOLPS'21},\n  title = {{Naïve Transient Cast Insertion Isn’t (That) Bad}},\n  year = {2021},\n  month_numeric = {7}\n}\n"}, {"author"=>"Dominik Aumayr, Stefan Marr, Sophie Kaleba, Elisa Gonzalez Boix, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"D.", "last"=>"Aumayr"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"S.", "last"=>"Kaleba"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"With concurrency being integral to most software systems, developers combine high-level concurrency models in the same application to tackle each problem with appropriate abstractions. While languages and libraries offer a wide range of concurrency models, debugging support for applications that combine them has not yet gained much attention. Record & replay aids debugging by deterministically reproducing recorded bugs, but is typically designed for a single concurrency model only.\r\nThis paper proposes a practical concurrency-model-agnostic record & replay approach for multi-paradigm concurrent programs, i.e. applications that combine concurrency models. Our approach traces high-level non- deterministic events by using a uniform model-agnostic trace format and infrastructure. This enables ordering- based record & replay support for a wide range of concurrency models, and thereby enables debugging of applications that combine them. In addition, it allows language implementors to add new concurrency mod- els and reuse the model-agnostic record & replay support.\r\nWe argue that a concurrency-model-agnostic record & replay is practical and enables advanced debugging support for a wide range of concurrency models. The evaluation shows that our approach is expressive and flexible enough to support record & replay of applications using threads & locks, communicating event loops, communicating sequential processes, software transactional memory and combinations of those concurrency models. For the actor model, we reach recording performance competitive with an optimized special-purpose record & replay solution. The average recording overhead on the Savina actor benchmark suite is 10% (min. 0%, max. 23%). The performance for other concurrency models and combinations thereof is at a similar level.\r\nWe believe our concurrency-model-agnostic approach helps developers of applications that mix and match concurrency models. We hope that this substrate inspires new tools and languages making building and maintaining of multi-paradigm concurrent applications simpler and safer.", "title"=>"Capturing High-level Nondeterminism in Concurrent Programs for Practical Concurrency Model Agnostic Record & Replay", "bibtype"=>"article", "type"=>"", "journal"=>"The Art, Science, and Engineering of Programming", "year"=>"2021", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"dd132fe351941768d8e358b78400c776", "publisher"=>"AOSA Inc.", "series"=>"Programming", "series_venue"=>"Programming", "school"=>"", "doi"=>"10.22152/programming-journal.org/2021/5/14", "howpublished"=>"", "number"=>"3", "pdf"=>"https://stefan-marr.de/downloads/prog21-aumayr-et-al-capturing-high-level-nondeterminism-in-concurrent-programs-for-practical-concurrency-model-agnostic-record-replay.pdf", "pages"=>"39", "publication_date"=>"28 feb 2021", "bibtex"=>"@article{Aumayr:2021:AgnosticRR,\n  abstract = {With concurrency being integral to most software systems, developers combine high-level concurrency models in the same application to tackle each problem with appropriate abstractions. While languages and libraries offer a wide range of concurrency models, debugging support for applications that combine them has not yet gained much attention. Record & replay aids debugging by deterministically reproducing recorded bugs, but is typically designed for a single concurrency model only.\r\n  This paper proposes a practical concurrency-model-agnostic record & replay approach for multi-paradigm concurrent programs, i.e. applications that combine concurrency models. Our approach traces high-level non- deterministic events by using a uniform model-agnostic trace format and infrastructure. This enables ordering- based record & replay support for a wide range of concurrency models, and thereby enables debugging of applications that combine them. In addition, it allows language implementors to add new concurrency mod- els and reuse the model-agnostic record & replay support.\r\n  We argue that a concurrency-model-agnostic record & replay is practical and enables advanced debugging support for a wide range of concurrency models. The evaluation shows that our approach is expressive and flexible enough to support record & replay of applications using threads & locks, communicating event loops, communicating sequential processes, software transactional memory and combinations of those concurrency models. For the actor model, we reach recording performance competitive with an optimized special-purpose record & replay solution. The average recording overhead on the Savina actor benchmark suite is 10% (min. 0%, max. 23%). The performance for other concurrency models and combinations thereof is at a similar level.\r\n  We believe our concurrency-model-agnostic approach helps developers of applications that mix and match concurrency models. We hope that this substrate inspires new tools and languages making building and maintaining of multi-paradigm concurrent applications simpler and safer.},\n  author = {Aumayr, Dominik and Marr, Stefan and Kaleba, Sophie and Gonzalez Boix, Elisa and Mössenböck, Hanspeter},\n  day = {28},\n  doi = {10.22152/programming-journal.org/2021/5/14},\n  issn = {2473-7321},\n  journal = {The Art, Science, and Engineering of Programming},\n  keywords = {Actors CSP Concurrency MeMyPublication MultiParadigm MultiThreading Nondeterministic RecordReplay SOMns STM myown},\n  month = feb,\n  number = {3},\n  pages = {39},\n  pdf = {https://stefan-marr.de/downloads/prog21-aumayr-et-al-capturing-high-level-nondeterminism-in-concurrent-programs-for-practical-concurrency-model-agnostic-record-replay.pdf},\n  publisher = {AOSA Inc.},\n  series = {Programming},\n  title = {{Capturing High-level Nondeterminism in Concurrent Programs for Practical Concurrency Model Agnostic Record & Replay}},\n  volume = {5},\n  year = {2021},\n  month_numeric = {2}\n}\n"}, {"author"=>"Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}], "title"=>"17th International Conference on Managed Programming Languages and Runtimes", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2020", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"9477c24c6ab6b4926873df06b9bc95f4", "publisher"=>"ACM", "series"=>"MPLR'20", "series_venue"=>"MPLR", "school"=>"", "doi"=>"10.1145/3426182", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"nov 2020", "bibtex"=>"@proceedings{MPLR:2020,\n  author = {Marr, Stefan},\n  doi = {10.1145/3426182},\n  editor = {Marr, Stefan},\n  isbn = {978-1-4503-8853-5},\n  keywords = {Conference LanguageImplementation MPLR ManagedLanguages MeMyPublication Proceeding myown},\n  month = nov,\n  publisher = {ACM},\n  series = {MPLR'20},\n  title = {17th International Conference on Managed Programming Languages and Runtimes},\n  url = {https://mplr2020.cs.manchester.ac.uk/},\n  venue = {Manchester, UK},\n  year = {2020},\n  month_numeric = {11}\n}\n"}, {"author"=>"Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}], "title"=>"The Art, Science, and Engineering of Programming", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2020", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"9e7a2df8e9023710d996b28fdc26e103", "publisher"=>"AOSA Inc.", "series"=>"Programming", "series_venue"=>"Programming", "school"=>"", "doi"=>"10.22152/programming-journal.org/2020/4/issue3", "howpublished"=>"", "number"=>"3", "pdf"=>"", "pages"=>nil, "publication_date"=>"feb 2020", "bibtex"=>"@proceedings{Marr:2020:P20I3,\n  author = {Marr, Stefan},\n  doi = {10.22152/programming-journal.org/2020/4/issue3},\n  editor = {Marr, Stefan},\n  issn = {2473-7321},\n  keywords = {MeMyPublication myown},\n  month = feb,\n  number = {3},\n  publisher = {AOSA Inc.},\n  series = {Programming},\n  title = {The Art, Science, and Engineering of Programming},\n  url = {https://programming-journal.org/2020/4/issue3/},\n  volume = {4},\n  year = {2020},\n  month_numeric = {2}\n}\n"}, {"author"=>"Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}], "title"=>"The Art, Science, and Engineering of Programming", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"7205b75d2a22fbc7cd4b2ea6dd8b913a", "publisher"=>"AOSA Inc.", "series"=>"Programming", "series_venue"=>"Programming", "school"=>"", "doi"=>"10.22152/programming-journal.org/2020/4/issue2", "howpublished"=>"", "number"=>"2", "pdf"=>"", "pages"=>nil, "publication_date"=>"oct 2019", "bibtex"=>"@proceedings{Marr:2019:P20I2,\n  author = {Marr, Stefan},\n  doi = {10.22152/programming-journal.org/2020/4/issue2},\n  editor = {Marr, Stefan},\n  issn = {2473-7321},\n  keywords = {MeMyPublication myown},\n  month = oct,\n  number = {2},\n  publisher = {AOSA Inc.},\n  series = {Programming},\n  title = {The Art, Science, and Engineering of Programming},\n  url = {https://programming-journal.org/2020/4/issue2/},\n  volume = {4},\n  year = {2019},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}], "title"=>"The Art, Science, and Engineering of Programming", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"7205b75d2a22fbc7cd4b2ea6dd8b913a", "publisher"=>"AOSA Inc.", "series"=>"Programming", "series_venue"=>"Programming", "school"=>"", "doi"=>"10.22152/programming-journal.org/2020/4/issue1", "howpublished"=>"", "number"=>"1", "pdf"=>"", "pages"=>nil, "publication_date"=>"jun 2019", "bibtex"=>"@proceedings{Marr:2019:P20I1,\n  author = {Marr, Stefan},\n  doi = {10.22152/programming-journal.org/2020/4/issue1},\n  editor = {Marr, Stefan},\n  issn = {2473-7321},\n  keywords = {MeMyPublication myown},\n  month = jun,\n  number = {1},\n  publisher = {AOSA Inc.},\n  series = {Programming},\n  title = {The Art, Science, and Engineering of Programming},\n  url = {https://programming-journal.org/2020/4/issue1/},\n  volume = {4},\n  year = {2019},\n  month_numeric = {6}\n}\n"}, {"author"=>"Stefan Marr, Juan Fumero", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"J.", "last"=>"Fumero"}], "title"=>"DLS 2019: Proceedings of the 15th ACM SIGPLAN International Symposium on Dynamic Languages", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"23488dfd5f604aa779dac47371a1765f", "publisher"=>"ACM", "series"=>"DLS", "series_venue"=>"DLS", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"20 oct 2019", "bibtex"=>"@proceedings{Marr:2019:DLS,\n  author = {Marr, Stefan and Fumero, Juan},\n  day = {20},\n  editor = {Marr, Stefan and Fumero, Juan},\n  isbn = {978-1-4503-6996-1},\n  keywords = {DLS19 DynamicLanguages MeMyPublication Proceedings myown},\n  location = {Athens, Greece},\n  month = oct,\n  publisher = {ACM},\n  series = {DLS},\n  title = {DLS 2019: Proceedings of the 15th ACM SIGPLAN International Symposium on Dynamic Languages},\n  url = {https://dl.acm.org/citation.cfm?id=3359619},\n  year = {2019},\n  month_numeric = {10}\n}\n"}, {"author"=>"Isaac Oscar Gariano, Richard Roberts, Stefan Marr, Michael Homer, James Noble", "author_abbr_firstname"=>[{"first"=>"I., O.", "last"=>"Gariano"}, {"first"=>"R.", "last"=>"Roberts"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"Homer"}, {"first"=>"J.", "last"=>"Noble"}], "abstract"=>"One form of type checking used in gradually typed language is transient type checking: whenever an object ‘flows’ through code with a type annotation, the object is dynamically checked to ensure it has the methods required by the annotation. Just-in-time compilation and optimisation in virtual machines can eliminate much of the overhead of run-time transient type checks. Unfortunately this optimisation is not uniform: some type checks will significantly decrease, or even increase, a program’s performance.  In this paper, we refine the so called “Takikawa” protocol, and use it to identify which type annotations have the greatest effects on performance. In particular, we show how graphing the performance of such benchmarks when varying which type annotations are present in the source code can be used to discern potential patterns in performance. We demonstrate our approach by testing the Moth virtual machine: for many of the benchmarks where Moth’s transient type checking impacts performance, we have been able to identify one or two specific type annotations that are the likely cause. Without these type annotations, the performance impact of transient type checking becomes negligible.  Using our technique programmers can optimise programs by removing expensive type checks, and VM engineers can identify new opportunities for compiler optimisation.", "title"=>"Which of My Transient Type Checks Are Not (Almost) Free?", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 11th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages", "interhash"=>"c62c7366351d5af493cc5b3b205b30d1", "publisher"=>"ACM", "series"=>"VMIL'19", "series_venue"=>"VMIL", "school"=>"", "doi"=>"10.1145/3358504.3361232", "howpublished"=>"", "number"=>"", "pdf"=>"https://stefan-marr.de/downloads/vmil19-gariano-et-al-which-of-my-transient-type-checks-are-not-almost-free.pdf", "pages"=>"58&ndash;66", "publication_date"=>"22 oct 2019", "bibtex"=>"@inproceedings{Gariano:2019:MTT,\n  abstract = {One form of type checking used in gradually typed language is transient type checking: whenever an object ‘flows’ through code with a type annotation, the object is dynamically checked to ensure it has the methods required by the annotation. Just-in-time compilation and optimisation in virtual machines can eliminate much of the overhead of run-time transient type checks. Unfortunately this optimisation is not uniform: some type checks will significantly decrease, or even increase, a program’s performance.  In this paper, we refine the so called “Takikawa” protocol, and use it to identify which type annotations have the greatest effects on performance. In particular, we show how graphing the performance of such benchmarks when varying which type annotations are present in the source code can be used to discern potential patterns in performance. We demonstrate our approach by testing the Moth virtual machine: for many of the benchmarks where Moth’s transient type checking impacts performance, we have been able to identify one or two specific type annotations that are the likely cause. Without these type annotations, the performance impact of transient type checking becomes negligible.  Using our technique programmers can optimise programs by removing expensive type checks, and VM engineers can identify new opportunities for compiler optimisation.},\n  acmid = {3361232},\n  author = {Gariano, Isaac Oscar and Roberts, Richard and Marr, Stefan and Homer, Michael and Noble, James},\n  booktitle = {Proceedings of the 11th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages},\n  day = {22},\n  doi = {10.1145/3358504.3361232},\n  isbn = {978-1-4503-6987-9},\n  keywords = {Grace GradualTyping MeMyPublication Moth Performance TransientTypes Visualization myown},\n  location = {Athens, Greece},\n  month = oct,\n  numpages = {9},\n  pages = {58--66},\n  pdf = {https://stefan-marr.de/downloads/vmil19-gariano-et-al-which-of-my-transient-type-checks-are-not-almost-free.pdf},\n  publisher = {ACM},\n  series = {VMIL'19},\n  title = {{Which of My Transient Type Checks Are Not (Almost) Free?}},\n  year = {2019},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr, Walter Cazzola", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"W.", "last"=>"Cazzola"}], "title"=>"&lt;Programming&gt;'19: Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"14feaebffd25343451f917ddb9eaffcd", "publisher"=>"ACM", "series"=>"ICPS", "series_venue"=>"ICPS", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"apr 2019", "bibtex"=>"@proceedings{Marr:2019:Programming19,\n  author = {Marr, Stefan and Cazzola, Walter},\n  editor = {Marr, Stefan and Cazzola, Walter},\n  isbn = {978-1-4503-6257-3},\n  keywords = {MeMyPublication Proceedings Programming Workshops myown},\n  location = {Genova, Italy},\n  month = apr,\n  publisher = {ACM},\n  series = {ICPS},\n  title = {{&lt;Programming&gt;'19: Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming}},\n  url = {https://dl.acm.org/citation.cfm?id=3328433},\n  year = {2019},\n  month_numeric = {4}\n}\n"}, {"author"=>"Dominik Aumayr, Stefan Marr, Elisa Gonzalez Boix, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"D.", "last"=>"Aumayr"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"The actor model is popular for many types of server applications. Efficient snapshotting of applications is crucial in the deployment of pre-initialized applications or moving running applications to different machines, e.g for debugging purposes. A key issue is that snapshotting blocks all other operations. In modern latency-sensitive applications, stopping the application to persist its state needs to be avoided, because users may not tolerate the increased request latency. In order to minimize the impact of snapshotting on request latency, our approach persists the application’s state asynchronously by capturing partial heaps, completing snapshots step by step. Additionally, our solution is transparent and supports arbitrary object graphs. We prototyped our snapshotting approach on top of the Truffle/Graal platform and evaluated it with the Savina benchmarks and the Acme Air microservice application. When performing a snapshot every thousand Acme Air requests, the number of slow requests ( 0.007% of all requests) with latency above 100ms increases by 5.43%. Our Savina microbenchmark results detail how different utilization patterns impact snapshotting cost. To the best of our knowledge, this is the first system that enables asynchronous snapshotting of actor applications, i.e. without stop-the-world synchronization, and thereby minimizes the impact on latency. We thus believe it enables new deployment and debugging options for actor systems.", "title"=>"Asynchronous Snapshots of Actor Systems for Latency-Sensitive Applications", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes", "interhash"=>"3a0a4d1d320671827801a2d67a047c69", "publisher"=>"ACM", "series"=>"MPLR'19", "series_venue"=>"MPLR", "school"=>"", "doi"=>"10.1145/3357390.3361019", "howpublished"=>"", "number"=>"", "pdf"=>"https://stefan-marr.de/downloads/mplr19-aumayr-et-al-asynchronous-snapshots-of-actor-systems-for-latency-sensitive-applications.pdf", "pages"=>"157&ndash;171", "publication_date"=>"oct 2019", "bibtex"=>"@inproceedings{Aumayr:2019:ASnap,\n  abstract = {The actor model is popular for many types of server applications. Efficient snapshotting of applications is crucial in the deployment of pre-initialized applications or moving running applications to different machines, e.g for debugging purposes. A key issue is that snapshotting blocks all other operations. In modern latency-sensitive applications, stopping the application to persist its state needs to be avoided, because users may not tolerate the increased request latency. In order to minimize the impact of snapshotting on request latency, our approach persists the application’s state asynchronously by capturing partial heaps, completing snapshots step by step. Additionally, our solution is transparent and supports arbitrary object graphs. We prototyped our snapshotting approach on top of the Truffle/Graal platform and evaluated it with the Savina benchmarks and the Acme Air microservice application. When performing a snapshot every thousand Acme Air requests, the number of slow requests ( 0.007% of all requests) with latency above 100ms increases by 5.43%. Our Savina microbenchmark results detail how different utilization patterns impact snapshotting cost. To the best of our knowledge, this is the first system that enables asynchronous snapshotting of actor applications, i.e. without stop-the-world synchronization, and thereby minimizes the impact on latency. We thus believe it enables new deployment and debugging options for actor systems.},\n  acceptancerate = {0.61},\n  author = {Aumayr, Dominik and Marr, Stefan and Gonzalez Boix, Elisa and Mössenböck, Hanspeter},\n  booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes},\n  doi = {10.1145/3357390.3361019},\n  isbn = {978-1-4503-6977-0},\n  keywords = {AcmeAir Actors Benchmarking Concurrency Dominik Latency MPLR MeMyPublication Snapshots myown},\n  month = oct,\n  pages = {157--171},\n  pdf = {https://stefan-marr.de/downloads/mplr19-aumayr-et-al-asynchronous-snapshots-of-actor-systems-for-latency-sensitive-applications.pdf},\n  publisher = {ACM},\n  series = {MPLR'19},\n  title = {{Asynchronous Snapshots of Actor Systems for Latency-Sensitive Applications}},\n  year = {2019},\n  month_numeric = {10}\n}\n"}, {"author"=>"Benoit Daloze, Stefan Marr, Daniele Bonetta", "author_abbr_firstname"=>[{"first"=>"B.", "last"=>"Daloze"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"D.", "last"=>"Bonetta"}], "title"=>"Efficient and Thread-Safe Objects for Dynamically-Typed Languages", "bibtype"=>"patent", "type"=>"", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"22567066002f909f21ee8732f2bd3fad", "publisher"=>"", "series"=>"none", "series_venue"=>"none", "school"=>"", "doi"=>"", "howpublished"=>"US Patent Application", "number"=>"2017/0277467", "pdf"=>"", "pages"=>nil, "publication_date"=>"sep 2017", "bibtex"=>"@patent{Daloze:2017:TSO-P,\n  author = {Daloze, Benoit and Marr, Stefan and Bonetta, Daniele},\n  howpublished = {US Patent Application},\n  keywords = {MeMyPublication Objects ThreadSafe Truffle myown patent},\n  month = sep,\n  number = {2017/0277467},\n  title = {{Efficient and Thread-Safe Objects for Dynamically-Typed Languages}},\n  year = {2017},\n  month_numeric = {9}\n}\n"}, {"author"=>"Stephen Kell, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Kell"}, {"first"=>"S.", "last"=>"Marr"}], "title"=>"VMIL 2018: Proceedings of the 10th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"a069c97e6159a373347f5bf16e86a217", "publisher"=>"ACM", "series"=>"SPLASH Workshop", "series_venue"=>"SPLASH Workshop", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"4 nov 2018", "bibtex"=>"@proceedings{VMIL:2018,\n  author = {Kell, Stephen and Marr, Stefan},\n  day = {4},\n  isbn = {978-1-4503-6071-5},\n  keywords = {Compilation GarbageCollection MeMyPublication Proceedings VirtualMachines Workshop myown},\n  location = {Boston, MA, USA},\n  month = nov,\n  publisher = {ACM},\n  series = {SPLASH Workshop},\n  title = {VMIL 2018: Proceedings of the 10th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages},\n  year = {2018},\n  month_numeric = {11}\n}\n"}, {"author"=>"Guido Chari, Elisa Gonzalez Boix, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"G.", "last"=>"Chari"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"S.", "last"=>"Marr"}], "title"=>"Meta 2018: Proceedings of the 3rd ACM SIGPLAN International Workshop on Meta-Programming Techniques and Reflection", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"bd5d54c591ddfdec61175b2239455de8", "publisher"=>"ACM", "series"=>"SPLASH Workshop", "series_venue"=>"SPLASH Workshop", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"5 nov 2018", "bibtex"=>"@proceedings{Meta:2018,\n  author = {Chari, Guido and Gonzalez Boix, Elisa and Marr, Stefan},\n  day = {5},\n  editor = {Chari, Guido and Gonzalez Boix, Elisa and Marr, Stefan},\n  isbn = {978-1-4503-6068-5},\n  keywords = {MeMyPublication Metaprogramming Proceedings Workshop myown},\n  location = {Boston, MA, USA},\n  month = nov,\n  publisher = {ACM},\n  series = {SPLASH Workshop},\n  title = {Meta 2018: Proceedings of the 3rd ACM SIGPLAN International Workshop on Meta-Programming Techniques and Reflection},\n  url = {https://dl.acm.org/citation.cfm?id=3281074},\n  year = {2018},\n  month_numeric = {11}\n}\n"}, {"author"=>"Manuel Rigger, Stefan Marr, Bram Adams, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"Rigger"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"B.", "last"=>"Adams"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"C programs can use compiler builtins to provide functionality that the C language lacks. On Linux, GCC provides several thousands of builtins that are also supported by other mature compilers, such as Clang and ICC. Maintainers of other tools lack guidance on whether and which builtins should be implemented to support popular projects. To assist tool developers who want to support GCC builtins, we analyzed builtin use in 4,913 C projects from GitHub. We found that 37% of these projects relied on at least one builtin. Supporting an increasing proportion of projects requires support of an exponentially increasing number of builtins; however, implementing only 10 builtins already covers over 30% of the projects. Since we found that many builtins in our corpus remained unused, the effort needed to support 90% of the projects is moderate, requiring about 110 builtins to be implemented. For each project, we analyzed the evolution of builtin use over time and found that the majority of projects mostly added builtins. This suggests that builtins are not a legacy feature and must be supported in future tools. Systematic testing of builtin support in existing tools revealed that many lacked support for builtins either partially or completely; we also discovered incorrect implementations in various tools, including the formally verified CompCert compiler.", "title"=>"Understanding GCC Builtins to Develop Better Tools", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering", "interhash"=>"2e0c055aaa1570116b20ed6956b42102", "publisher"=>"ACM", "series"=>"ESEC/FSE'19", "series_venue"=>"ESEC/FSE", "school"=>"", "doi"=>"10.1145/3338906.3338907", "howpublished"=>"", "number"=>"", "pdf"=>"https://stefan-marr.de/downloads/fse19-rigger-et-al-understanding-gcc-builtins-to-develop-better-tools.pdf", "pages"=>nil, "publication_date"=>"aug 2019", "bibtex"=>"@inproceedings{Rigger:2019:Builtins,\n  abstract = {C programs can use compiler builtins to provide functionality that the C language lacks. On Linux, GCC provides several thousands of builtins that are also supported by other mature compilers, such as Clang and ICC. Maintainers of other tools lack guidance on whether and which builtins should be implemented to support popular projects. To assist tool developers who want to support GCC builtins, we analyzed builtin use in 4,913 C projects from GitHub. We found that 37% of these projects relied on at least one builtin. Supporting an increasing proportion of projects requires support of an exponentially increasing number of builtins; however, implementing only 10 builtins already covers over 30% of the projects. Since we found that many builtins in our corpus remained unused, the effort needed to support 90% of the projects is moderate, requiring about 110 builtins to be implemented. For each project, we analyzed the evolution of builtin use over time and found that the majority of projects mostly added builtins. This suggests that builtins are not a legacy feature and must be supported in future tools. Systematic testing of builtin support in existing tools revealed that many lacked support for builtins either partially or completely; we also discovered incorrect implementations in various tools, including the formally verified CompCert compiler.},\n  acceptancerate = {0.24},\n  author = {Rigger, Manuel and Marr, Stefan and Adams, Bram and Mössenböck, Hanspeter},\n  booktitle = {Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},\n  doi = {10.1145/3338906.3338907},\n  isbn = {978-1-4503-5572-8/19/08},\n  keywords = {Builtins Compiler EmpiricalStudy GCC GitHub MeMyPublication Survey Use myown},\n  month = aug,\n  pdf = {https://stefan-marr.de/downloads/fse19-rigger-et-al-understanding-gcc-builtins-to-develop-better-tools.pdf},\n  publisher = {ACM},\n  series = {ESEC/FSE'19},\n  title = {{Understanding GCC Builtins to Develop Better Tools}},\n  year = {2019},\n  month_numeric = {8}\n}\n"}, {"author"=>"Carmen Torres Lopez, Robbert Gurdeep Singh, Stefan Marr, Elisa Gonzalez Boix, Christophe Scholliers", "author_abbr_firstname"=>[{"first"=>"C.", "last"=>"Torres Lopez"}, {"first"=>"R.", "last"=>"Gurdeep Singh"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"C.", "last"=>"Scholliers"}], "abstract"=>"Many of today's software systems are parallel or concurrent. With the rise of Node.js and more generally event-loop architectures, many systems need to handle concurrency. However, its non-deterministic behavior makes it hard to reproduce bugs. Today's interactive debuggers unfortunately do not support developers in debugging non-deterministic issues. They only allow us to explore a single execution path. Therefore, some bugs may never be reproduced in the debugging session, because the right conditions are not triggered. As a solution, we propose multiverse debugging, a new approach for debugging non-deterministic programs that allows developers to observe all possible execution paths of a parallel program and debug it interactively. We introduce the concepts of multiverse breakpoints and stepping, which can halt a program in different execution paths, i.e. universes. We apply multiverse debugging to AmbientTalk, an actor-based language, resulting in Voyager, a multiverse debugger implemented on top of the AmbientTalk operational semantics. We provide a proof of non-interference, i.e., we prove that observing the behavior of a program by the debugger does not affect the behavior of that program and vice versa. Multiverse debugging establishes the foundation for debugging non-deterministic programs interactively, which we believe can aid the development of parallel and concurrent systems.", "title"=>"Multiverse Debugging: Non-deterministic Debugging for Non-deterministic Programs", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"https://stefan-marr.de/2019/07/what-if-we-could-see-all-concurrency-bugs-in-the-debugger/", "html"=>"", "appendix"=>"https://doi.org/10.4230/DARTS.5.2.4", "booktitle"=>"33rd European Conference on Object-Oriented Programming", "interhash"=>"7c3a074d2fcba3978f74fa7279a15f3d", "publisher"=>"Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik", "series"=>"ECOOP'19", "series_venue"=>"ECOOP", "school"=>"", "doi"=>"10.4230/LIPIcs.ECOOP.2019.27", "howpublished"=>"", "number"=>"27", "pdf"=>"https://stefan-marr.de/downloads/ecoop19-torres-lopez-et-al-multiverse-debugging-non-deterministic-debugging-for-non-deterministic-programs.pdf", "pages"=>"27:1&ndash;27:30", "publication_date"=>"15 jul 2019", "bibtex"=>"@inproceedings{TorresLopez:2019:MD,\n  abstract = {Many of today's software systems are parallel or concurrent. With the rise of Node.js and more generally event-loop architectures, many systems need to handle concurrency. However, its non-deterministic behavior makes it hard to reproduce bugs. Today's interactive debuggers unfortunately do not support developers in debugging non-deterministic issues. They only allow us to explore a single execution path. Therefore, some bugs may never be reproduced in the debugging session, because the right conditions are not triggered. As a solution, we propose multiverse debugging, a new approach for debugging non-deterministic programs that allows developers to observe all possible execution paths of a parallel program and debug it interactively. We introduce the concepts of multiverse breakpoints and stepping, which can halt a program in different execution paths, i.e. universes. We apply multiverse debugging to AmbientTalk, an actor-based language, resulting in Voyager, a multiverse debugger implemented on top of the AmbientTalk operational semantics. We provide a proof of non-interference, i.e., we prove that observing the behavior of a program by the debugger does not affect the behavior of that program and vice versa. Multiverse debugging establishes the foundation for debugging non-deterministic programs interactively, which we believe can aid the development of parallel and concurrent systems.},\n  acceptancerate = {0.37},\n  appendix = {https://doi.org/10.4230/DARTS.5.2.4},\n  author = {Torres Lopez, Carmen and Gurdeep Singh, Robbert and Marr, Stefan and Gonzalez Boix, Elisa and Scholliers, Christophe},\n  blog = {https://stefan-marr.de/2019/07/what-if-we-could-see-all-concurrency-bugs-in-the-debugger/},\n  booktitle = {33rd European Conference on Object-Oriented Programming},\n  day = {15},\n  doi = {10.4230/LIPIcs.ECOOP.2019.27},\n  isbn = {978-3-95977-111-5},\n  issn = {1868-8969},\n  keywords = {Actors AmbientTalk Concurrency Debugging FormalSemantics Formalism MeMyPublication Multiverse NonDeterminism Redex myown},\n  month = jul,\n  number = {27},\n  pages = {27:1--27:30},\n  pdf = {https://stefan-marr.de/downloads/ecoop19-torres-lopez-et-al-multiverse-debugging-non-deterministic-debugging-for-non-deterministic-programs.pdf},\n  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},\n  series = {ECOOP'19},\n  title = {{Multiverse Debugging: Non-deterministic Debugging for Non-deterministic Programs}},\n  volume = {134},\n  year = {2019},\n  month_numeric = {7}\n}\n"}, {"author"=>"Richard Roberts, Stefan Marr, Michael Homer, James Noble", "author_abbr_firstname"=>[{"first"=>"R.", "last"=>"Roberts"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"Homer"}, {"first"=>"J.", "last"=>"Noble"}], "abstract"=>"Transient gradual typing imposes run-time type tests that typically cause a linear slowdown. This performance impact discourages the use of type annotations because adding types to a program makes the program slower. A virtual machine can employ standard just-in-time optimizations to reduce the overhead of transient checks to near zero. These optimizations can give gradually-typed languages performance comparable to state-of-the-art dynamic languages, so programmers can add types to their code without affecting their programs' performance.", "title"=>"Transient Typechecks are (Almost) Free", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2019", "blog"=>"", "html"=>"", "appendix"=>"https://github.com/gracelang/moth-benchmarks/blob/papers/ecoop19/index.md", "booktitle"=>"33rd European Conference on Object-Oriented Programming", "interhash"=>"4d73580859cb20340f888400c8eb7adc", "publisher"=>"Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik", "series"=>"ECOOP'19", "series_venue"=>"ECOOP", "school"=>"", "doi"=>"10.4230/LIPIcs.ECOOP.2019.5", "howpublished"=>"", "number"=>"5", "pdf"=>"https://stefan-marr.de/downloads/ecoop19-roberts-et-al-transient-typechecks-are-almost-free.pdf", "pages"=>"5:1&ndash;5:28", "publication_date"=>"15 jul 2019", "bibtex"=>"@inproceedings{Roberts:2019:TTAF,\n  abstract = {Transient gradual typing imposes run-time type tests that typically cause a linear slowdown. This performance impact discourages the use of type annotations because adding types to a program makes the program slower. A virtual machine can employ standard just-in-time optimizations to reduce the overhead of transient checks to near zero. These optimizations can give gradually-typed languages performance comparable to state-of-the-art dynamic languages, so programmers can add types to their code without affecting their programs' performance.},\n  acceptancerate = {0.37},\n  appendix = {https://github.com/gracelang/moth-benchmarks/blob/papers/ecoop19/index.md},\n  author = {Roberts, Richard and Marr, Stefan and Homer, Michael and Noble, James},\n  booktitle = {33rd European Conference on Object-Oriented Programming},\n  day = {15},\n  doi = {10.4230/LIPIcs.ECOOP.2019.5},\n  isbn = {978-3-95977-111-5},\n  issn = {1868-8969},\n  keywords = {Benchmarking Evaluation Graal Grace GradualTyping MeMyPublication Moth SOMns TransientTypes Truffle myown},\n  month = jul,\n  number = {5},\n  pages = {5:1--5:28},\n  pdf = {https://stefan-marr.de/downloads/ecoop19-roberts-et-al-transient-typechecks-are-almost-free.pdf},\n  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},\n  series = {ECOOP'19},\n  title = {Transient Typechecks are (Almost) Free},\n  volume = {134},\n  year = {2019},\n  month_numeric = {7}\n}\n"}, {"author"=>"Elisa Gonzalez Boix, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"S.", "last"=>"Marr"}], "title"=>"Meta'16 Workshop Special Issue", "bibtype"=>"proceedings", "type"=>"", "journal"=>"Journal of Object Technology", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"3f3ddb8bdd6e7d613d0f2ca8d1223ff9", "publisher"=>"AITO", "series"=>"Meta'16", "series_venue"=>"Meta", "school"=>"", "doi"=>"10.5381/jot.2018.17.1.e1", "howpublished"=>"", "number"=>"1", "pdf"=>"", "pages"=>nil, "publication_date"=>"nov 2018", "bibtex"=>"@proceedings{GonzalezBoix:2018:Meta16,\n  author = {Gonzalez Boix, Elisa and Marr, Stefan},\n  doi = {10.5381/jot.2018.17.1.e1},\n  editor = {Gonzalez Boix, Elisa and Marr, Stefan},\n  issn = {1660-1769},\n  journal = {Journal of Object Technology},\n  keywords = {MeMyPublication MetaProgramming Reflection myown},\n  month = nov,\n  number = {1},\n  publisher = {AITO},\n  series = {Meta'16},\n  title = {Meta'16 Workshop Special Issue},\n  url = {http://www.jot.fm/contents/issue_2018_01.html},\n  volume = {17},\n  year = {2018},\n  month_numeric = {11}\n}\n"}, {"author"=>"Elisa Gonzalez Boix, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"S.", "last"=>"Marr"}], "title"=>"Introduction to the Meta’16 Workshop Special Issue", "bibtype"=>"article", "type"=>"", "journal"=>"Journal of Object Technology", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"3088f94a621bb59e1bf9ee2e7254de1a", "publisher"=>"", "series"=>"Meta'16", "series_venue"=>"Meta", "school"=>"", "doi"=>"10.5381/jot.2018.17.1.e1", "howpublished"=>"", "number"=>"1", "pdf"=>"http://www.jot.fm/issues/issue_2018_01/editorial.pdf", "pages"=>"1&ndash;2", "publication_date"=>"nov 2018", "bibtex"=>"@article{GonzalezBoix:2018:editorial,\n  author = {Gonzalez Boix, Elisa and Marr, Stefan},\n  doi = {10.5381/jot.2018.17.1.e1},\n  issn = {1660-1769},\n  journal = {Journal of Object Technology},\n  keywords = {Editorial MeMyPublication Meta16 MetaProgramming Reflection myown},\n  month = nov,\n  note = {(editorial)},\n  number = {1},\n  pages = {1--2},\n  pdf = {http://www.jot.fm/issues/issue_2018_01/editorial.pdf},\n  series = {Meta'16},\n  title = {Introduction to the Meta’16 Workshop Special Issue},\n  url = {http://www.jot.fm/contents/issue_2018_01/editorial.html},\n  volume = {17},\n  year = {2018},\n  month_numeric = {11}\n}\n"}, {"author"=>"Stefan Marr, Richard Roberts, James Noble", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"R.", "last"=>"Roberts"}, {"first"=>"J.", "last"=>"Noble"}], "title"=>"Newspeak and Truffle: A Platform for Grace?", "bibtype"=>"presentation", "type"=>"Presentation", "journal"=>"", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"de32efa2559fe0657b038ceeff0b5563", "publisher"=>"", "series"=>"Grace'18", "series_venue"=>"Grace", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/grace18-marr-et-al-newspeak-and-truffle-a-platform-for-grace.pdf", "pages"=>"3", "publication_date"=>"4 nov 2018", "bibtex"=>"@presentation{Marr:2018:Grace,\n  author = {Marr, Stefan and Roberts, Richard and Noble, James},\n  day = {4},\n  keywords = {Compilation Grace MeMyPublication Truffle myown},\n  month = nov,\n  pages = {3},\n  pdf = {http://stefan-marr.de/downloads/grace18-marr-et-al-newspeak-and-truffle-a-platform-for-grace.pdf},\n  series = {Grace'18},\n  title = {{Newspeak and Truffle: A Platform for Grace?}},\n  type = {Presentation},\n  year = {2018},\n  month_numeric = {11}\n}\n"}, {"author"=>"Stefan Marr, Jennifer B. Sartor", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"J., B.", "last"=>"Sartor"}], "title"=>"&lt;Programming&gt;'18 Companion: Conference Companion of the 2nd International Conference on Art, Science, and Engineering of Programming", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"c196d5b536046800c4d339db1ed96960", "publisher"=>"ACM", "series"=>"ICPS", "series_venue"=>"ICPS", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"apr 2018", "bibtex"=>"@proceedings{Marr:2018,\n  author = {Marr, Stefan and Sartor, Jennifer B.},\n  editor = {Marr, Stefan and Sartor, Jennifer B.},\n  isbn = {978-1-4503-5513-1},\n  keywords = {MeMyPublication Proceedings Programming Workshops myown},\n  location = {Nice, France},\n  month = apr,\n  publisher = {ACM},\n  series = {ICPS},\n  title = {&lt;Programming&gt;'18 Companion: Conference Companion of the 2nd International Conference on Art, Science, and Engineering of Programming},\n  url = {https://dl.acm.org/citation.cfm?id=3191697},\n  year = {2018},\n  month_numeric = {4}\n}\n"}, {"author"=>"Benoit Daloze, Arie Tal, Stefan Marr, Hanspeter Mössenböck, Erez Petrank", "author_abbr_firstname"=>[{"first"=>"B.", "last"=>"Daloze"}, {"first"=>"A.", "last"=>"Tal"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"H.", "last"=>"Mössenböck"}, {"first"=>"E.", "last"=>"Petrank"}], "abstract"=>"Dynamic programming languages such as Python and Ruby are widely used, and much effort is spent on making them efficient. One substantial research effort in this direction is the enabling of parallel code execution. While there has been significant progress, making dynamic collections efficient, scalable, and thread-safe is an open issue. Typical programs in dynamic languages use few but versatile collection types. Such collections are an important ingredient of dynamic environments, but are difficult to make safe, efficient, and scalable.\r\n\r\nIn this paper, we propose an approach for efficient and concurrent collections by gradually increasing synchronization levels according to the dynamic needs of each collection instance. Collections reachable only by a single thread have no synchronization, arrays accessed in bounds have minimal synchronization, and for the general case, we adopt the Layout Lock paradigm and extend its design with a lightweight version that fits the setting of dynamic languages. We apply our approach to Ruby’s Array and Hash collections. Our experiments show that our approach has no overhead on single-threaded benchmarks, scales linearly for Array and Hash accesses, achieves the same scalability as Fortran and Java for classic parallel algorithms, and scales better than other Ruby implementations on Ruby workloads.", "title"=>"Parallelization of Dynamic Languages: Synchronizing Built-in Collections", "bibtype"=>"article", "type"=>"", "journal"=>"Proceedings of the ACM on Programming Languages", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"5b2a1c5fa8b7b0a4d91cc97e3b6c8c6d", "publisher"=>"", "series"=>"OOPSLA'18", "series_venue"=>"OOPSLA", "school"=>"", "doi"=>"10.1145/3276478", "howpublished"=>"", "number"=>"OOPSLA", "pdf"=>"http://stefan-marr.de/downloads/oopsla18-daloze-et-al-parallelization-of-dynamic-languages-synchronizing-built-in-collections.pdf", "pages"=>"108:1&ndash;108:30", "publication_date"=>"nov 2018", "bibtex"=>"@article{Daloze:2018:TSC,\n  abstract = {Dynamic programming languages such as Python and Ruby are widely used, and much effort is spent on making them efficient. One substantial research effort in this direction is the enabling of parallel code execution. While there has been significant progress, making dynamic collections efficient, scalable, and thread-safe is an open issue. Typical programs in dynamic languages use few but versatile collection types. Such collections are an important ingredient of dynamic environments, but are difficult to make safe, efficient, and scalable.\r\n  \r\n  In this paper, we propose an approach for efficient and concurrent collections by gradually increasing synchronization levels according to the dynamic needs of each collection instance. Collections reachable only by a single thread have no synchronization, arrays accessed in bounds have minimal synchronization, and for the general case, we adopt the Layout Lock paradigm and extend its design with a lightweight version that fits the setting of dynamic languages. We apply our approach to Ruby’s Array and Hash collections. Our experiments show that our approach has no overhead on single-threaded benchmarks, scales linearly for Array and Hash accesses, achieves the same scalability as Fortran and Java for classic parallel algorithms, and scales better than other Ruby implementations on Ruby workloads.},\n  author = {Daloze, Benoit and Tal, Arie and Marr, Stefan and Mössenböck, Hanspeter and Petrank, Erez},\n  doi = {10.1145/3276478},\n  journal = {Proceedings of the ACM on Programming Languages},\n  keywords = {Builtin Collections Graal GraalVM LocalShared MeMyPublication Ruby ThreadSafety Truffle TruffleRuby myown},\n  month = nov,\n  number = {OOPSLA},\n  pages = {108:1--108:30},\n  pdf = {http://stefan-marr.de/downloads/oopsla18-daloze-et-al-parallelization-of-dynamic-languages-synchronizing-built-in-collections.pdf},\n  series = {OOPSLA'18},\n  title = {{Parallelization of Dynamic Languages: Synchronizing Built-in Collections}},\n  volume = {2},\n  year = {2018},\n  month_numeric = {11}\n}\n"}, {"author"=>"Dominik Aumayr, Stefan Marr, Clément Béra, Elisa Gonzalez Boix, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"D.", "last"=>"Aumayr"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"C.", "last"=>"Béra"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"With the ubiquity of parallel commodity hardware, developers turn to high-level concurrency models such as the actor model to lower the complexity of concurrent software. However, debugging concurrent software is hard, especially for concurrency models with a limited set of supporting tools. Such tools often deal only with the underlying threads and locks, which obscures the view on e.g. actors and messages and thereby introduces additional complexity.\r\nTo improve on this situation, we present a low-overhead record & replay approach for actor languages. It allows one to debug concurrency issues deterministically based on a previously recorded trace. Our evaluation shows that the average run-time overhead for tracing on benchmarks from the Savina suite is 10% (min. 0%, max. 20%). For Acme-Air, a modern web application, we see a maximum increase of 1% in latency for HTTP requests and about 1.4 MB/s of trace data. These results are a  first step towards deterministic replay debugging of actor systems in production.", "title"=>"Efficient and Deterministic Record &amp; Replay for Actor Languages", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2018", "blog"=>"http://stefan-marr.de/2018/08/deterministic-replay-for-actors/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 15th International Conference on Managed Languages and Runtimes", "interhash"=>"e8239222d17e0f94c53cc2217ec3b682", "publisher"=>"ACM", "series"=>"ManLang'18", "series_venue"=>"ManLang", "school"=>"", "doi"=>"10.1145/3237009.3237015", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/manlang18-aumayr-et-al-efficient-and-deterministic-record-and-replay-for-actor-languages.pdf", "pages"=>nil, "publication_date"=>"12--13 sep 2018", "bibtex"=>"@inproceedings{Aumayr:2018:RR,\n  abstract = {With the ubiquity of parallel commodity hardware, developers turn to high-level concurrency models such as the actor model to lower the complexity of concurrent software. However, debugging concurrent software is hard, especially for concurrency models with a limited set of supporting tools. Such tools often deal only with the underlying threads and locks, which obscures the view on e.g. actors and messages and thereby introduces additional complexity.\r\n  To improve on this situation, we present a low-overhead record & replay approach for actor languages. It allows one to debug concurrency issues deterministically based on a previously recorded trace. Our evaluation shows that the average run-time overhead for tracing on benchmarks from the Savina suite is 10% (min. 0%, max. 20%). For Acme-Air, a modern web application, we see a maximum increase of 1% in latency for HTTP requests and about 1.4 MB/s of trace data. These results are a  first step towards deterministic replay debugging of actor systems in production.},\n  acceptancerate = {0.72},\n  author = {Aumayr, Dominik and Marr, Stefan and Béra, Clément and Gonzalez Boix, Elisa and Mössenböck, Hanspeter},\n  blog = {http://stefan-marr.de/2018/08/deterministic-replay-for-actors/},\n  booktitle = {Proceedings of the 15th International Conference on Managed Languages and Runtimes},\n  day = {12--13},\n  doi = {10.1145/3237009.3237015},\n  isbn = {978-1-4503-6424-9/18/09},\n  keywords = {Actors Concurrency Debugging Determinism MeMyPublication Replay SOMns Tracing Truffle},\n  month = sep,\n  pdf = {http://stefan-marr.de/downloads/manlang18-aumayr-et-al-efficient-and-deterministic-record-and-replay-for-actor-languages.pdf},\n  publisher = {ACM},\n  series = {ManLang'18},\n  title = {{Efficient and Deterministic Record \\& Replay for Actor Languages}},\n  year = {2018},\n  month_numeric = {9}\n}\n"}, {"author"=>"Carmen Torres Lopez, Stefan Marr, Hanspeter Mössenböck, Elisa Gonzalez Boix", "author_abbr_firstname"=>[{"first"=>"C.", "last"=>"Torres Lopez"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"H.", "last"=>"Mössenböck"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}], "abstract"=>"The actor model is an attractive foundation for developing concurrent applications because actors are isolated concurrent entities that communicate through asynchronous messages and do not share state. Thereby, they avoid concurrency bugs such as data races, but are not immune to concurrency bugs in general.", "title"=>"A Study of Concurrency Bugs and Advanced Development Support for Actor-based Programs", "bibtype"=>"article", "type"=>"", "journal"=>"", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Programming with Actors: State-of-the-Art and Research Perspectives", "interhash"=>"e803234f745df3a9bc0bdf5ab1305e18", "publisher"=>"Springer", "series"=>"AGERE!'16 (LNCS)", "series_venue"=>"AGERE!", "school"=>"", "doi"=>"10.1007/978-3-030-00302-9_6", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/lncs-torres-lopez-et-al-study-of-concurrency-bugs-and-advanced-development-support-for-actor-based-programs.pdf", "pages"=>"155&ndash;185", "publication_date"=>"sep 2018", "bibtex"=>"@article{TorresLopez:2018:BugSurvey,\n  abstract = {The actor model is an attractive foundation for developing concurrent applications because actors are isolated concurrent entities that communicate through asynchronous messages and do not share state. Thereby, they avoid concurrency bugs such as data races, but are not immune to concurrency bugs in general.},\n  author = {Torres Lopez, Carmen and Marr, Stefan and Mössenböck, Hanspeter and Gonzalez Boix, Elisa},\n  booktitle = {Programming with Actors: State-of-the-Art and Research Perspectives},\n  doi = {10.1007/978-3-030-00302-9_6},\n  editor = {Ricci, Alessandro and Haller, Philipp},\n  isbn = {978-3-030-00302-9},\n  keywords = {ActorLanguages Analysis Bug Concurrency Debugging EventLoopConcurrency MeMyPublication Testing Truffle myown},\n  month = sep,\n  numpages = {32},\n  pages = {155--185},\n  pdf = {http://stefan-marr.de/downloads/lncs-torres-lopez-et-al-study-of-concurrency-bugs-and-advanced-development-support-for-actor-based-programs.pdf},\n  publisher = {Springer},\n  series = {AGERE!'16 (LNCS)},\n  title = {{A Study of Concurrency Bugs and Advanced Development Support for Actor-based Programs}},\n  volume = {10789},\n  year = {2018},\n  month_numeric = {9}\n}\n"}, {"author"=>"Guido Chari, Diego Garbervetsky, Stefan Marr, Stéphane Ducasse", "author_abbr_firstname"=>[{"first"=>"G.", "last"=>"Chari"}, {"first"=>"D.", "last"=>"Garbervetsky"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"S.", "last"=>"Ducasse"}], "abstract"=>"VMs are complex pieces of software that implement programming language semantics in an efficient, portable, and secure way. Unfortunately, mainstream VMs provide applications with few mechanisms to alter execution semantics or memory management at run time. We argue that this limits the evolvability and maintainability of running systems for both, the application domain, e.g., to support unforeseen requirements, and the VM domain, e.g., to modify the organization of objects in memory. This work explores the idea of incorporating reflective capabilities into the VM domain and analyzes its impact in the context of software adaptation tasks. We characterize the notion of a fully reflective VM, a kind of VM that provides means for its own observability and modifiability at run time. This enables programming languages to adapt the underlying VM to changing requirements. We propose a reference architecture for such VMs and present TruffleMATE as a prototype for this architecture. We evaluate the mechanisms TruffleMATE provides to deal with unanticipated dynamic adaptation scenarios for security, optimization, and profiling aspects. In contrast to existing alternatives, we observe that TruffleMATE is able to handle all scenarios, using less than 50 lines of code for each, and without interfering with the application&#x0027;s logic.", "title"=>"Fully Reflective Execution Environments: Virtual Machines for More Flexible Software", "bibtype"=>"article", "type"=>"", "journal"=>"IEEE Transactions on Software Engineering", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"29ce5a999cfca39530e5858486de1bfb", "publisher"=>"", "series"=>"IEEE TSE", "series_venue"=>"IEEE TSE", "school"=>"", "doi"=>"10.1109/TSE.2018.2812715", "howpublished"=>"", "number"=>"99", "pdf"=>"http://stefan-marr.de/downloads/tse18-chari-et-al-fully-reflective-execution-environments.pdf", "pages"=>"1&ndash;20", "publication_date"=>"mar 2018", "bibtex"=>"@article{Chari:2018:FREE,\n  abstract = {VMs are complex pieces of software that implement programming language semantics in an efficient, portable, and secure way. Unfortunately, mainstream VMs provide applications with few mechanisms to alter execution semantics or memory management at run time. We argue that this limits the evolvability and maintainability of running systems for both, the application domain, e.g., to support unforeseen requirements, and the VM domain, e.g., to modify the organization of objects in memory. This work explores the idea of incorporating reflective capabilities into the VM domain and analyzes its impact in the context of software adaptation tasks. We characterize the notion of a fully reflective VM, a kind of VM that provides means for its own observability and modifiability at run time. This enables programming languages to adapt the underlying VM to changing requirements. We propose a reference architecture for such VMs and present TruffleMATE as a prototype for this architecture. We evaluate the mechanisms TruffleMATE provides to deal with unanticipated dynamic adaptation scenarios for security, optimization, and profiling aspects. In contrast to existing alternatives, we observe that TruffleMATE is able to handle all scenarios, using less than 50 lines of code for each, and without interfering with the application&#x0027;s logic.},\n  author = {Chari, Guido and Garbervetsky, Diego and Marr, Stefan and Ducasse, Stéphane},\n  doi = {10.1109/TSE.2018.2812715},\n  issn = {0098-5589},\n  journal = {IEEE Transactions on Software Engineering},\n  keywords = {Compilation Design Mate MeMyPublication MetaObjectProtocol MetaProgramming Reflection Truffle VM myown},\n  month = mar,\n  number = {99},\n  pages = {1--20},\n  pdf = {http://stefan-marr.de/downloads/tse18-chari-et-al-fully-reflective-execution-environments.pdf},\n  series = {IEEE TSE},\n  title = {{Fully Reflective Execution Environments: Virtual Machines for More Flexible Software}},\n  volume = {PP},\n  year = {2018},\n  month_numeric = {3}\n}\n"}, {"author"=>"Stefan Marr, Benoit Daloze", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"B.", "last"=>"Daloze"}], "abstract"=>"While an integral part of all programming languages, the design of collection libraries is rarely studied. This work briefly reviews the collection libraries of 14 languages to identify possible design dimensions. Some languages have surprisingly few but versatile collections, while others have large libraries with many specialized collections. Based on the identified design dimensions, we argue that a small collection library with only a sequence, a map, and a set type are a suitable choice to facilitate exploratory programming. Such a design minimizes the number of decisions programmers have to make when dealing with collections, and it improves discoverability of collection operations. We further discuss techniques that make their implementation practical from a performance perspective. Based on these arguments, we conclude that languages which aim to support exploratory programming should strive for small and versatile collection libraries.", "title"=>"Few Versatile vs. Many Specialized Collections: How to design a collection library for exploratory programming?", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2018", "blog"=>"http://stefan-marr.de/2018/03/how-to-design-collection-libraries/", "html"=>"http://stefan-marr.de/papers/px-marr-daloze-few-versatile-vs-many-specialized-collections/", "appendix"=>"", "booktitle"=>"Proceedings of Programming Experience Workshop", "interhash"=>"0f02e13340bffa5027ba860ae1e1a4d0", "publisher"=>"ACM", "series"=>"PX/18", "series_venue"=>"PX", "school"=>"", "doi"=>"10.1145/3191697.3214334", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/px18-marr-daloze-few-versatile-vs-many-specialized-collections.pdf", "pages"=>"135&ndash;143", "publication_date"=>"10 apr 2018", "bibtex"=>"@inproceedings{Marr:2018:COLL-PX,\n  abstract = {While an integral part of all programming languages, the design of collection libraries is rarely studied. This work briefly reviews the collection libraries of 14 languages to identify possible design dimensions. Some languages have surprisingly few but versatile collections, while others have large libraries with many specialized collections. Based on the identified design dimensions, we argue that a small collection library with only a sequence, a map, and a set type are a suitable choice to facilitate exploratory programming. Such a design minimizes the number of decisions programmers have to make when dealing with collections, and it improves discoverability of collection operations. We further discuss techniques that make their implementation practical from a performance perspective. Based on these arguments, we conclude that languages which aim to support exploratory programming should strive for small and versatile collection libraries.},\n  acceptancerate = {1.00},\n  author = {Marr, Stefan and Daloze, Benoit},\n  blog = {http://stefan-marr.de/2018/03/how-to-design-collection-libraries/},\n  booktitle = {Proceedings of Programming Experience Workshop},\n  day = {10},\n  doi = {10.1145/3191697.3214334},\n  html = {http://stefan-marr.de/papers/px-marr-daloze-few-versatile-vs-many-specialized-collections/},\n  isbn = {978-1-4503-5513-1},\n  keywords = {Analysis Collections Design Framework Implementation Library MeMyPublication Opinion Survey myown},\n  month = apr,\n  numpages = {9},\n  pages = {135--143},\n  pdf = {http://stefan-marr.de/downloads/px18-marr-daloze-few-versatile-vs-many-specialized-collections.pdf},\n  publisher = {ACM},\n  series = {PX/18},\n  title = {{Few Versatile vs. Many Specialized Collections: How to design a collection library for exploratory programming?}},\n  year = {2018},\n  month_numeric = {4}\n}\n"}, {"author"=>"Manuel Rigger, Stefan Marr, Stephen Kell, David Leopoldseder, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"Rigger"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"S.", "last"=>"Kell"}, {"first"=>"D.", "last"=>"Leopoldseder"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"C codebases frequently embed nonportable and unstandardized elements such as inline assembly code. Such elements are not well understood, which poses a problem to tool developers who aspire to support C code. This paper investigates the use of x86-64 inline assembly in 1264 C projects from GitHub and combines qualitative and quantitative analyses to answer questions that tool authors may have. We found that 28.1% of the most popular projects contain inline assembly code, although the majority contain only a few fragments with just one or two instructions. The most popular instructions constitute a small subset concerned largely with multicore semantics, performance optimization, and hardware control. Our findings are intended to help developers of C-focused tools, those testing compilers, and language designers seeking to reduce the reliance on inline assembly. They may also aid the design of tools focused on inline assembly itself.", "title"=>"An Analysis of x86-64 Inline Assembly in C Programs", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2018", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"VEE ’18: 14th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments", "interhash"=>"52e0669b54b01388250ea0ca63817ec6", "publisher"=>"", "series"=>"VEE'18", "series_venue"=>"VEE", "school"=>"", "doi"=>"10.1145/3186411.3186418", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/vee18-rigger-et-al-an-analysis-of-x86-64-inline-assembly-in-c-programs.pdf", "pages"=>"84&ndash;99", "publication_date"=>"mar 2018", "bibtex"=>"@inproceedings{Rigger:2018:Inline,\n  abstract = {C codebases frequently embed nonportable and unstandardized elements such as inline assembly code. Such elements are not well understood, which poses a problem to tool developers who aspire to support C code. This paper investigates the use of x86-64 inline assembly in 1264 C projects from GitHub and combines qualitative and quantitative analyses to answer questions that tool authors may have. We found that 28.1% of the most popular projects contain inline assembly code, although the majority contain only a few fragments with just one or two instructions. The most popular instructions constitute a small subset concerned largely with multicore semantics, performance optimization, and hardware control. Our findings are intended to help developers of C-focused tools, those testing compilers, and language designers seeking to reduce the reliance on inline assembly. They may also aid the design of tools focused on inline assembly itself.},\n  acceptancerate = {0.32},\n  author = {Rigger, Manuel and Marr, Stefan and Kell, Stephen and Leopoldseder, David and Mössenböck, Hanspeter},\n  booktitle = {VEE ’18: 14th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments},\n  doi = {10.1145/3186411.3186418},\n  isbn = {978-1-4503-5579-7/18/03},\n  keywords = {Analysis Assembly C Empirical GitHub MeMyPublication Study Survey myown},\n  month = mar,\n  numpages = {16},\n  pages = {84--99},\n  pdf = {http://stefan-marr.de/downloads/vee18-rigger-et-al-an-analysis-of-x86-64-inline-assembly-in-c-programs.pdf},\n  series = {VEE'18},\n  title = {{An Analysis of x86-64 Inline Assembly in C Programs}},\n  year = {2018},\n  month_numeric = {3}\n}\n"}, {"author"=>"Carmen Torres Lopez, Elisa Gonzalez Boix, Christophe Scholliers, Stefan Marr, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"C.", "last"=>"Torres Lopez"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"C.", "last"=>"Scholliers"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"Since the multicore revolution, software systems are more and more inherently concurrent. Debugging such concurrent software systems is still hard, but in the recent years new tools and techniques are being proposed. For such novel debugging techniques, the main question is how to make sure that the proposed techniques are sufficiently expressive. In this paper, we explore a formal foundation that allows researchers to identify debugging techniques and assess how complete their features are in the context of message-passing concurrency. In particular, we describe a principled approach for defining the operational semantics of a debugger. Subsequently, we apply this technique to derive the operational semantics for a communicating event-loop debugger. We show that our technique scales for defining the semantics of a wide set of novel breakpoints recently proposed by systems such as REME-D and Kómpos. To the best of our knowledge, this is the first formal semantics for debugging asynchronous message passing-based concurrency models.", "title"=>"A Principled Approach Towards Debugging Communicating Event-loops", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 7th ACM SIGPLAN International Workshop on Programming Based on Actors, Agents, and Decentralized Control", "interhash"=>"2a896452a15ce25ac07b1a724e238615", "publisher"=>"ACM", "series"=>"AGERE!'17", "series_venue"=>"AGERE!", "school"=>"", "doi"=>"10.1145/3141834.3141839", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/agere17-torres-lopez-et-al-a-principled-approach-towards-debugging-communicating-event-loops.pdf", "pages"=>"41&ndash;49", "publication_date"=>"23 oct 2017", "bibtex"=>"@inproceedings{TorresLopez:2017:PAT,\n  abstract = {Since the multicore revolution, software systems are more and more inherently concurrent. Debugging such concurrent software systems is still hard, but in the recent years new tools and techniques are being proposed. For such novel debugging techniques, the main question is how to make sure that the proposed techniques are sufficiently expressive. In this paper, we explore a formal foundation that allows researchers to identify debugging techniques and assess how complete their features are in the context of message-passing concurrency. In particular, we describe a principled approach for defining the operational semantics of a debugger. Subsequently, we apply this technique to derive the operational semantics for a communicating event-loop debugger. We show that our technique scales for defining the semantics of a wide set of novel breakpoints recently proposed by systems such as REME-D and Kómpos. To the best of our knowledge, this is the first formal semantics for debugging asynchronous message passing-based concurrency models.},\n  acceptancerate = {0.75},\n  acmid = {3141839},\n  author = {Torres Lopez, Carmen and Gonzalez Boix, Elisa and Scholliers, Christophe and Marr, Stefan and Mössenböck, Hanspeter},\n  booktitle = {Proceedings of the 7th ACM SIGPLAN International Workshop on Programming Based on Actors, Agents, and Decentralized Control},\n  day = {23},\n  doi = {10.1145/3141834.3141839},\n  isbn = {978-1-4503-5516-2},\n  keywords = {ActorModel Actors Concurrency Debugging Formalization MeMyPublication Messages Stepping myown},\n  location = {Vancouver, BC, Canada},\n  month = oct,\n  numpages = {9},\n  pages = {41--49},\n  pdf = {http://stefan-marr.de/downloads/agere17-torres-lopez-et-al-a-principled-approach-towards-debugging-communicating-event-loops.pdf},\n  publisher = {ACM},\n  series = {AGERE!'17},\n  title = {A Principled Approach Towards Debugging Communicating Event-loops},\n  year = {2017},\n  month_numeric = {10}\n}\n"}, {"author"=>"Shigeru Chiba, Elisa Gonzalez Boix, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Chiba"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"S.", "last"=>"Marr"}], "title"=>"Meta 2017: Proceedings of the 2nd ACM SIGPLAN International Workshop on Meta-Programming Techniques and Reflection", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"390d180634b8abc7ec48ae45ee6e4e06", "publisher"=>"ACM", "series"=>"SPLASH Workshop", "series_venue"=>"SPLASH Workshop", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"22 oct 2017", "bibtex"=>"@proceedings{Meta:2017,\n  author = {Chiba, Shigeru and Gonzalez Boix, Elisa and Marr, Stefan},\n  day = {22},\n  editor = {Chiba, Shigeru and Gonzalez Boix, Elisa and Marr, Stefan},\n  isbn = {978-1-4503-5523-0},\n  keywords = {MeMyPublication Metaprogramming Proceedings Workshop myown},\n  location = {Vancouver, BC, Canada},\n  month = oct,\n  publisher = {ACM},\n  series = {SPLASH Workshop},\n  title = {Meta 2017: Proceedings of the 2nd ACM SIGPLAN International Workshop on Meta-Programming Techniques and Reflection},\n  url = {https://dl.acm.org/citation.cfm?id=3141517},\n  year = {2017},\n  month_numeric = {10}\n}\n"}, {"author"=>"Josef Eisl, Stefan Marr, Thomas Würthinger, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"J.", "last"=>"Eisl"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"Würthinger"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"Register allocation is an integral part of compilation, regardless of whether a compiler aims for fast compilation or optimal code quality. State-of-the-art dynamic compilers often use global register allocation approaches such as linear scan. Recent results suggest that non-global trace-based register allocation approaches can compete with global approaches in terms of allocation quality. Instead of processing the whole compilation unit (i.e., method) at once, a trace-based register allocator divides the problem into linear code segments, called traces.\r\n\r\nIn this work, we present a register allocation framework that can exploit the additional flexibility of traces to select different allocation strategies based on the characteristics of a trace. This provides us with fine-grained control over the trade-off between compile time and peak performance in a just-in-time compiler.\r\n\r\nOur framework features three allocation strategies: a linear-scan-based approach that achieves good code quality, a single-pass bottom-up strategy that aims for short allocation times, and an allocator for trivial traces.\r\n\r\nTo demonstrate the flexibility of the framework, we select 8 allocation policies and show their impact on compile time and peak performance. This approach can reduce allocation time by 7%–43% at a peak performance penalty of about 1%–11% on average.\r\n\r\nFor systems that do not focus on peak performance, our approach allows to adjust the time spent for register allocation, and therefore the overall compilation time, thus finding the optimal balance between compile time and peak performance according to an application's requirements.", "title"=>"Trace Register Allocation Policies: Compile-time vs. Performance Trade-offs", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 14th International Conference on Managed Languages and Runtimes", "interhash"=>"fa5e3685a5ebbf4f73b568ca5c70b0f3", "publisher"=>"ACM", "series"=>"ManLang'17", "series_venue"=>"ManLang", "school"=>"", "doi"=>"10.1145/3132190.3132209", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/manlang17-eisl-et-al-trace-register-allocation-policies.pdf", "pages"=>nil, "publication_date"=>"sep 2017", "bibtex"=>"@inproceedings{Eisl:2017:TRAP,\n  abstract = {Register allocation is an integral part of compilation, regardless of whether a compiler aims for fast compilation or optimal code quality. State-of-the-art dynamic compilers often use global register allocation approaches such as linear scan. Recent results suggest that non-global trace-based register allocation approaches can compete with global approaches in terms of allocation quality. Instead of processing the whole compilation unit (i.e., method) at once, a trace-based register allocator divides the problem into linear code segments, called traces.\r\n  \r\n  In this work, we present a register allocation framework that can exploit the additional flexibility of traces to select different allocation strategies based on the characteristics of a trace. This provides us with fine-grained control over the trade-off between compile time and peak performance in a just-in-time compiler.\r\n  \r\n  Our framework features three allocation strategies: a linear-scan-based approach that achieves good code quality, a single-pass bottom-up strategy that aims for short allocation times, and an allocator for trivial traces.\r\n  \r\n  To demonstrate the flexibility of the framework, we select 8 allocation policies and show their impact on compile time and peak performance. This approach can reduce allocation time by 7%–43% at a peak performance penalty of about 1%–11% on average.\r\n  \r\n  For systems that do not focus on peak performance, our approach allows to adjust the time spent for register allocation, and therefore the overall compilation time, thus finding the optimal balance between compile time and peak performance according to an application's requirements.},\n  acceptancerate = {0.45},\n  author = {Eisl, Josef and Marr, Stefan and Würthinger, Thomas and Mössenböck, Hanspeter},\n  booktitle = {Proceedings of the 14th International Conference on Managed Languages and Runtimes},\n  doi = {10.1145/3132190.3132209},\n  isbn = {978-1-4503-5340-3/17/09},\n  keywords = {Compilation JIT MeMyPublication Optimization Policies RegisterAllocation Trace-based myown},\n  location = {Prague, Czech Republic},\n  month = sep,\n  numpages = {13},\n  pdf = {http://stefan-marr.de/downloads/manlang17-eisl-et-al-trace-register-allocation-policies.pdf},\n  publisher = {ACM},\n  series = {ManLang'17},\n  title = {Trace Register Allocation Policies: Compile-time vs. Performance Trade-offs},\n  year = {2017},\n  month_numeric = {9}\n}\n"}, {"author"=>"Javier Pimás, Javier Burroni, Jean Baptiste Arnaud, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"J.", "last"=>"Pimás"}, {"first"=>"J.", "last"=>"Burroni"}, {"first"=>"J., B.", "last"=>"Arnaud"}, {"first"=>"S.", "last"=>"Marr"}], "abstract"=>"In dynamic object-oriented languages, low-level mechanisms such as just-in-time compilation, object allocation, garbage collection (GC) and method dispatch are often handled by virtual machines (VMs). VMs are typically implemented using static languages, allowing only few changes at run time. In such systems, the VM is not part of the language and interfaces to memory management or method dispatch are fixed, not allowing for arbitrary adaptation. Furthermore, the implementation can typically not be inspected or debugged with standard tools used to work on application code.\r\n\r\nThis paper reports on our experience building Bee, a dynamic Smalltalk runtime, written in Smalltalk. Bee is a Dynamic Metacircular Runtime (DMR) and seamlessly integrates the VM into the application and thereby overcomes many restrictions of classic VMs, for instance by allowing arbitrary code modifications of the VM at run time. Furthermore, the approach enables developers to use their standard tools for application code also for the VM, allowing them to inspect, debug, understand, and modify a DMR seamlessly.\r\n\r\nWe detail our experience of implementing GC, compilation, and optimizations in a DMR. We discuss examples where we found that DMRs can improve understanding of the system, provide tighter control of the software stack, and facilitate research. We also show that in high-level benchmarks the Bee DMR performance is close to that of a widely used Smalltalk VM.", "title"=>"Garbage Collection and Efficiency in Dynamic Metacircular Runtimes", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 13th ACM SIGPLAN International Symposium on Dynamic Languages", "interhash"=>"2d6ee093c64feb5e1be6267505ee6c52", "publisher"=>"ACM", "series"=>"DLS'17", "series_venue"=>"DLS", "school"=>"", "doi"=>"10.1145/3133841.3133845", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/dls17-pimas-et-al-garbage-collection-and-efficiency-in-dynamic-metacircular-runtimes.pdf", "pages"=>nil, "publication_date"=>"24 oct 2017", "bibtex"=>"@inproceedings{pimas2017garbage,\n  abstract = {In dynamic object-oriented languages, low-level mechanisms such as just-in-time compilation, object allocation, garbage collection (GC) and method dispatch are often handled by virtual machines (VMs). VMs are typically implemented using static languages, allowing only few changes at run time. In such systems, the VM is not part of the language and interfaces to memory management or method dispatch are fixed, not allowing for arbitrary adaptation. Furthermore, the implementation can typically not be inspected or debugged with standard tools used to work on application code.\r\n  \r\n  This paper reports on our experience building Bee, a dynamic Smalltalk runtime, written in Smalltalk. Bee is a Dynamic Metacircular Runtime (DMR) and seamlessly integrates the VM into the application and thereby overcomes many restrictions of classic VMs, for instance by allowing arbitrary code modifications of the VM at run time. Furthermore, the approach enables developers to use their standard tools for application code also for the VM, allowing them to inspect, debug, understand, and modify a DMR seamlessly.\r\n  \r\n  We detail our experience of implementing GC, compilation, and optimizations in a DMR. We discuss examples where we found that DMRs can improve understanding of the system, provide tighter control of the software stack, and facilitate research. We also show that in high-level benchmarks the Bee DMR performance is close to that of a widely used Smalltalk VM.},\n  acceptancerate = {0.64},\n  author = {Pimás, Javier and Burroni, Javier and Arnaud, Jean Baptiste and Marr, Stefan},\n  booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Dynamic Languages},\n  day = {24},\n  doi = {10.1145/3133841.3133845},\n  isbn = {978-1-4503-5526-1/17/10},\n  keywords = {Bee DMR MeMyPublication MetaCircular MetaObjectProtocol Reflection Smalltalk myown},\n  location = {Vancouver, Canada},\n  month = oct,\n  note = {(acceptance rate 64%)},\n  numpages = {12},\n  pdf = {http://stefan-marr.de/downloads/dls17-pimas-et-al-garbage-collection-and-efficiency-in-dynamic-metacircular-runtimes.pdf},\n  publisher = {ACM},\n  series = {DLS'17},\n  title = {{Garbage Collection and Efficiency in Dynamic Metacircular Runtimes}},\n  year = {2017},\n  month_numeric = {10}\n}\n"}, {"author"=>"Matthias Grimmer, Stefan Marr, Mario Kahlhofer, Christian Wimmer, Thomas Würthinger, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"Grimmer"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"Kahlhofer"}, {"first"=>"C.", "last"=>"Wimmer"}, {"first"=>"T.", "last"=>"Würthinger"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"While Java is a statically-typed language, some of its features make it behave like a dynamically-typed language at run time. This includes Java’s boxing of primitive values as well as generics, which rely on type erasure.\r\n\r\nThis paper investigates how runtime technology for dynamically-typed languages such as JavaScript and Python can be used for Java bytecode. Using optimistic optimizations, we specialize bytecode instructions that access references in such a way, that they can handle primitive data directly and also specialize data structures in order to avoid boxing for primitive types. Our evaluation shows that these optimizations can be successfully applied to a statically-typed language such as Java and can also improve performance significantly. With this approach, we get an efficient implementation of Java's generics, avoid changes to the Java language, and maintain backwards compatibility, allowing existing code to benefit from our optimization transparently.", "title"=>"Applying Optimizations for Dynamically-typed Languages to Java", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 14th International Conference on Managed Languages and Runtimes", "interhash"=>"20a606d561a9bf2a0fab64448c175c23", "publisher"=>"ACM", "series"=>"ManLang'17", "series_venue"=>"ManLang", "school"=>"", "doi"=>"10.1145/3132190.3132202", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/manlang17-grimmer-et-al-applying-optimizations-for-dynamically-typed-languages-to-java.pdf", "pages"=>nil, "publication_date"=>"sep 2017", "bibtex"=>"@inproceedings{Grimmer:2017:TJ,\n  abstract = {While Java is a statically-typed language, some of its features make it behave like a dynamically-typed language at run time. This includes Java’s boxing of primitive values as well as generics, which rely on type erasure.\r\n  \r\n  This paper investigates how runtime technology for dynamically-typed languages such as JavaScript and Python can be used for Java bytecode. Using optimistic optimizations, we specialize bytecode instructions that access references in such a way, that they can handle primitive data directly and also specialize data structures in order to avoid boxing for primitive types. Our evaluation shows that these optimizations can be successfully applied to a statically-typed language such as Java and can also improve performance significantly. With this approach, we get an efficient implementation of Java's generics, avoid changes to the Java language, and maintain backwards compatibility, allowing existing code to benefit from our optimization transparently.},\n  acceptancerate = {0.45},\n  author = {Grimmer, Matthias and Marr, Stefan and Kahlhofer, Mario and Wimmer, Christian and Würthinger, Thomas and Mössenböck, Hanspeter},\n  booktitle = {Proceedings of the 14th International Conference on Managed Languages and Runtimes},\n  doi = {10.1145/3132190.3132202},\n  isbn = {978-1-4503-5340-3/17/09},\n  keywords = {MeMyPublication myown},\n  location = {Prague, Czech Republic},\n  month = sep,\n  numpages = {11},\n  pdf = {http://stefan-marr.de/downloads/manlang17-grimmer-et-al-applying-optimizations-for-dynamically-typed-languages-to-java.pdf},\n  publisher = {ACM},\n  series = {ManLang'17},\n  title = {{Applying Optimizations for Dynamically-typed Languages to Java}},\n  year = {2017},\n  month_numeric = {9}\n}\n"}, {"author"=>"Stefan Marr, Carmen Torres Lopez, Dominik Aumayr, Elisa Gonzalez Boix, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"C.", "last"=>"Torres Lopez"}, {"first"=>"D.", "last"=>"Aumayr"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"Today's complex software systems combine high-level concurrency models. Each model is used to solve a specific set of problems. Unfortunately, debuggers support only the low-level notions of threads and shared memory, forcing developers to reason about these notions instead of the high-level concurrency models they chose.\r\n\r\nThis paper proposes a concurrency-agnostic debugger protocol that decouples the debugger from the concurrency models employed by the target application. As a result, the underlying language runtime can define custom breakpoints, stepping operations, and execution events for each concurrency model it supports, and a debugger can expose them without having to be specifically adapted.\r\n\r\nWe evaluated the generality of the protocol by applying it to SOMns, a Newspeak implementation, which supports a diversity of concurrency models including communicating sequential processes, communicating event loops, threads and locks, fork/join parallelism, and software transactional memory. We implemented 21 breakpoints and 20 stepping operations for these concurrency models. For none of these, the debugger needed to be changed. Furthermore, we visualize all concurrent interactions independently of a specific concurrency model. To show that tooling for a specific concurrency model is possible, we visualize actor turns and message sends separately.", "title"=>"A Concurrency-Agnostic Protocol for Multi-Paradigm Concurrent Debugging Tools", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2017", "blog"=>"https://stefan-marr.de/2017/10/multi-paradigm-concurrent-debugging/", "html"=>"https://stefan-marr.de/papers/dls-marr-et-al-concurrency-agnostic-protocol-for-debugging/", "appendix"=>"", "booktitle"=>"Proceedings of the 13th ACM SIGPLAN International Symposium on Dynamic Languages", "interhash"=>"fd0460a53c7ec4f41c14ccb10cc22a9f", "publisher"=>"ACM", "series"=>"DLS'17", "series_venue"=>"DLS", "school"=>"", "doi"=>"10.1145/3133841.3133842", "howpublished"=>"", "number"=>"", "pdf"=>"https://stefan-marr.de/downloads/dls17-marr-et-al-concurrency-agnostic-protocol-for-debugging.pdf", "pages"=>"3&ndash;14", "publication_date"=>"24 oct 2017", "bibtex"=>"@inproceedings{Marr:2017:CPCD,\n  abstract = {Today's complex software systems combine high-level concurrency models. Each model is used to solve a specific set of problems. Unfortunately, debuggers support only the low-level notions of threads and shared memory, forcing developers to reason about these notions instead of the high-level concurrency models they chose.\r\n  \r\n  This paper proposes a concurrency-agnostic debugger protocol that decouples the debugger from the concurrency models employed by the target application. As a result, the underlying language runtime can define custom breakpoints, stepping operations, and execution events for each concurrency model it supports, and a debugger can expose them without having to be specifically adapted.\r\n  \r\n  We evaluated the generality of the protocol by applying it to SOMns, a Newspeak implementation, which supports a diversity of concurrency models including communicating sequential processes, communicating event loops, threads and locks, fork/join parallelism, and software transactional memory. We implemented 21 breakpoints and 20 stepping operations for these concurrency models. For none of these, the debugger needed to be changed. Furthermore, we visualize all concurrent interactions independently of a specific concurrency model. To show that tooling for a specific concurrency model is possible, we visualize actor turns and message sends separately.},\n  acceptancerate = {0.64},\n  author = {Marr, Stefan and Torres Lopez, Carmen and Aumayr, Dominik and Gonzalez Boix, Elisa and Mössenböck, Hanspeter},\n  blog = {https://stefan-marr.de/2017/10/multi-paradigm-concurrent-debugging/},\n  booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Dynamic Languages},\n  day = {24},\n  doi = {10.1145/3133841.3133842},\n  html = {https://stefan-marr.de/papers/dls-marr-et-al-concurrency-agnostic-protocol-for-debugging/},\n  isbn = {978-1-4503-5526-1/17/10},\n  keywords = {Breakpoints Concurrency Debugging MeMyPublication Stepping Tooling Visualization myown},\n  location = {Vancouver, Canada},\n  month = oct,\n  note = {(acceptance rate 64%)},\n  numpages = {12},\n  pages = {3--14},\n  pdf = {https://stefan-marr.de/downloads/dls17-marr-et-al-concurrency-agnostic-protocol-for-debugging.pdf},\n  publisher = {ACM},\n  series = {DLS'17},\n  title = {{A Concurrency-Agnostic Protocol for Multi-Paradigm Concurrent Debugging Tools}},\n  year = {2017},\n  month_numeric = {10}\n}\n"}, {"author"=>"Maarten Vandercammen, Stefan Marr, Coen De Roover", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"Vandercammen"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"C.", "last"=>"De Roover"}], "abstract"=>"Just-in-time compilation has proven an effective, though effort-intensive, choice for realizing performant language runtimes. Recently introduced JIT compilation frameworks advocate applying meta-compilation techniques such as partial evaluation or meta-tracing on simple interpreters to reduce the implementation effort. However, such frameworks are few and far between. Designed and highly optimized for performance, they are difficult to experiment with. We therefore present STRAF, a minimalistic yet flexible Scala framework for studying trace-based JIT compilation. STRAF is sufficiently general to support a diverse set of language interpreters, but also sufficiently extensible to enable experiments with trace recording and optimization. We demonstrate the former by plugging two different interpreters into STRAF. We demonstrate the latter by extending STRAF with e.g., constant folding and type-specialization optimizations, which are commonly found in dedicated trace-based JIT compilers. The evaluation shows that STRAF is suitable for prototyping new techniques and formalisms in the domain of trace-based JIT compilation.", "title"=>"A Flexible Framework for Studying Trace-Based Just-In-Time Compilation", "bibtype"=>"article", "type"=>"", "journal"=>"Computer Languages, Systems &amp; Structures", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"c826370d03ce27908b5e8909669292a5", "publisher"=>"", "series"=>"ComLan", "series_venue"=>"ComLan", "school"=>"", "doi"=>"10.1016/j.cl.2017.07.005", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/comlan17-vandercammen-et-al-a-flexible-framework-for-studying-trace-based-just-in-time-compilation.pdf", "pages"=>nil, "publication_date"=>"jul 2017", "bibtex"=>"@article{Vandercammen:2017:STRAF,\n  abstract = {Just-in-time compilation has proven an effective, though effort-intensive, choice for realizing performant language runtimes. Recently introduced JIT compilation frameworks advocate applying meta-compilation techniques such as partial evaluation or meta-tracing on simple interpreters to reduce the implementation effort. However, such frameworks are few and far between. Designed and highly optimized for performance, they are difficult to experiment with. We therefore present STRAF, a minimalistic yet flexible Scala framework for studying trace-based JIT compilation. STRAF is sufficiently general to support a diverse set of language interpreters, but also sufficiently extensible to enable experiments with trace recording and optimization. We demonstrate the former by plugging two different interpreters into STRAF. We demonstrate the latter by extending STRAF with e.g., constant folding and type-specialization optimizations, which are commonly found in dedicated trace-based JIT compilers. The evaluation shows that STRAF is suitable for prototyping new techniques and formalisms in the domain of trace-based JIT compilation.},\n  author = {Vandercammen, Maarten and Marr, Stefan and De Roover, Coen},\n  doi = {10.1016/j.cl.2017.07.005},\n  issn = {1477-8424},\n  journal = {Computer Languages, Systems \\& Structures},\n  keywords = {Framework Lisp MeMyPublication MetaTracing Scala Scheme Trace-basedJIT Tracing myown optimization semantics},\n  month = jul,\n  pdf = {http://stefan-marr.de/downloads/comlan17-vandercammen-et-al-a-flexible-framework-for-studying-trace-based-just-in-time-compilation.pdf},\n  series = {ComLan},\n  title = {{A Flexible Framework for Studying Trace-Based Just-In-Time Compilation}},\n  year = {2017},\n  month_numeric = {7}\n}\n"}, {"author"=>"Richard Roberts, Stefan Marr, Michael Homer, James Noble", "author_abbr_firstname"=>[{"first"=>"R.", "last"=>"Roberts"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"Homer"}, {"first"=>"J.", "last"=>"Noble"}], "abstract"=>"We adapt SOMns, a Truffle-based interpreter for Newspeak, to the Grace programming language. We highlight differences between the semantics of these languages and offer preliminary results showing that adaption is possible while retaining performance. The similarities between the languages promote the potential for adaption and code sharing between implementations. Through experimentation we intend to explore how the design of the tailored implementation; the flexibility of the underlying framework; and similarities between languages affect adaptability, and by doing so hope to realize a set of mechanisms that can be easily extended to create optimized VMs for object-orientated languages.", "title"=>"Toward Virtual Machine Adaption Rather than Reimplementation: Adapting SOMns for Grace", "bibtype"=>"presentation", "type"=>"Extended Abstract", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Workshop on Modern Language Runtimes, Ecosystems, and VMs", "interhash"=>"35ccb15ed976f2592662a98d80cef1d2", "publisher"=>"", "series"=>"MoreVMs'17", "series_venue"=>"MoreVMs", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/morevms17-roberts-et-al-toward-virtual-machine-adaption.pdf", "pages"=>nil, "publication_date"=>"3 apr 2017", "bibtex"=>"@presentation{Roberts:2017:VMAdaption,\n  abstract = {We adapt SOMns, a Truffle-based interpreter for Newspeak, to the Grace programming language. We highlight differences between the semantics of these languages and offer preliminary results showing that adaption is possible while retaining performance. The similarities between the languages promote the potential for adaption and code sharing between implementations. Through experimentation we intend to explore how the design of the tailored implementation; the flexibility of the underlying framework; and similarities between languages affect adaptability, and by doing so hope to realize a set of mechanisms that can be easily extended to create optimized VMs for object-orientated languages.},\n  author = {Roberts, Richard and Marr, Stefan and Homer, Michael and Noble, James},\n  booktitle = {Workshop on Modern Language Runtimes, Ecosystems, and VMs},\n  day = {3},\n  keywords = {Adaptation Grace MeMyPublication Truffle VM myown},\n  month = apr,\n  pdf = {http://stefan-marr.de/downloads/morevms17-roberts-et-al-toward-virtual-machine-adaption.pdf},\n  series = {MoreVMs'17},\n  title = {{Toward Virtual Machine Adaption Rather than Reimplementation: Adapting SOMns for Grace}},\n  type = {Extended Abstract},\n  year = {2017},\n  month_numeric = {4}\n}\n"}, {"author"=>"Guido Chari, Diego Garbervetsky, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"G.", "last"=>"Chari"}, {"first"=>"D.", "last"=>"Garbervetsky"}, {"first"=>"S.", "last"=>"Marr"}], "abstract"=>"Just-in-time compilers and their aggressive speculative optimizations reduced the performance gap between dynamic and static languages drastically. To successfully speculate, compilers rely on the program variability observed at run time to be low, and use heuristics to determine when optimization is beneficial. However, some variability patterns are hard to capture with heuristics. Specifically, ephemeral, warmup, rare, and highly indirect variability are challenges for today's compiler heuristics. As a consequence, they can lead to reduced application performance. However, these types of variability are identifiable at the application level and could be mitigated with information provided by developers. As a solution, we propose a metaobject protocol for dynamic compilation systems to enable application developers to provide such information at run time. As a proof of concept, we demonstrate performance improvements for a few scenarios in a dynamic language built on top of the Truffle and Graal system.", "title"=>"A Metaobject Protocol for Optimizing Application-Specific Run-Time Variability", "bibtype"=>"inproceedings", "type"=>"Position Paper", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 11th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems", "interhash"=>"c0c40883593a7f5b3eb7a7362d4b0dd1", "publisher"=>"", "series"=>"ICOOOLPS '17", "series_venue"=>"ICOOOLPS", "school"=>"", "doi"=>"10.1145/3098572.3098577", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/icooolps17-chari-et-al-a-mop-for-optimizing-run-time-variability.pdf", "pages"=>"5", "publication_date"=>"19 jun 2017", "bibtex"=>"@inproceedings{Chari:2017:JITMOP,\n  abstract = {Just-in-time compilers and their aggressive speculative optimizations reduced the performance gap between dynamic and static languages drastically. To successfully speculate, compilers rely on the program variability observed at run time to be low, and use heuristics to determine when optimization is beneficial. However, some variability patterns are hard to capture with heuristics. Specifically, ephemeral, warmup, rare, and highly indirect variability are challenges for today's compiler heuristics. As a consequence, they can lead to reduced application performance. However, these types of variability are identifiable at the application level and could be mitigated with information provided by developers. As a solution, we propose a metaobject protocol for dynamic compilation systems to enable application developers to provide such information at run time. As a proof of concept, we demonstrate performance improvements for a few scenarios in a dynamic language built on top of the Truffle and Graal system.},\n  author = {Chari, Guido and Garbervetsky, Diego and Marr, Stefan},\n  booktitle = {Proceedings of the 11th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems},\n  day = {19},\n  doi = {10.1145/3098572.3098577},\n  isbn = {978-1-4503-5088-4/17/06},\n  keywords = {Compiler JIT MOP MeMyPublication MetaProgramming Optimization myown},\n  month = jun,\n  pages = {5},\n  pdf = {http://stefan-marr.de/downloads/icooolps17-chari-et-al-a-mop-for-optimizing-run-time-variability.pdf},\n  series = {ICOOOLPS '17},\n  title = {{A Metaobject Protocol for Optimizing Application-Specific Run-Time Variability}},\n  type = {Position Paper},\n  year = {2017},\n  month_numeric = {6}\n}\n"}, {"author"=>"Guido Chari, Diego Garbervetsky, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"G.", "last"=>"Chari"}, {"first"=>"D.", "last"=>"Garbervetsky"}, {"first"=>"S.", "last"=>"Marr"}], "abstract"=>"It has become common for software systems to require or benefit from dynamic adaptation, i.e., to modify their behavior while they are running. Among the existing approaches to this problem, language-level solutions are appealing for scenarios in which fine-grained adaptation is needed, i.e., when the granularity of the modifications is that of individual objects, or for small applications where an architectural solution based on complex middleware is overkill. However, there is no consensus on which of the existing language-level approaches to adopt. A recent survey on self-adaptive systems asks [9]: Is it possible to adopt a single paradigm providing all required abstractions to implement adaptive systems?", "title"=>"Fully-reflective VMs for Ruling Software Adaptation", "bibtype"=>"inproceedings", "type"=>"Poster", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 39th International Conference on Software Engineering Companion", "interhash"=>"4bc35775c63fdfe67b6b1d279aab7254", "publisher"=>"IEEE", "series"=>"ICSE-C '17", "series_venue"=>"ICSE-C", "school"=>"", "doi"=>"10.1109/ICSE-C.2017.144", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/icse17-chari-et-al-fully-reflective-vms-for-software-adaptation.pdf", "pages"=>"229&ndash;231", "publication_date"=>"may 2017", "bibtex"=>"@inproceedings{Chari:2017:FVR,\n  abstract = {It has become common for software systems to require or benefit from dynamic adaptation, i.e., to modify their behavior while they are running. Among the existing approaches to this problem, language-level solutions are appealing for scenarios in which fine-grained adaptation is needed, i.e., when the granularity of the modifications is that of individual objects, or for small applications where an architectural solution based on complex middleware is overkill. However, there is no consensus on which of the existing language-level approaches to adopt. A recent survey on self-adaptive systems asks [9]: Is it possible to adopt a single paradigm providing all required abstractions to implement adaptive systems?},\n  acmid = {3098422},\n  author = {Chari, Guido and Garbervetsky, Diego and Marr, Stefan},\n  booktitle = {Proceedings of the 39th International Conference on Software Engineering Companion},\n  doi = {10.1109/ICSE-C.2017.144},\n  isbn = {978-1-5386-1589-8},\n  keywords = {Mate MeMyPublication myown poster},\n  location = {Buenos Aires, Argentina},\n  month = may,\n  numpages = {3},\n  pages = {229--231},\n  pdf = {http://stefan-marr.de/downloads/icse17-chari-et-al-fully-reflective-vms-for-software-adaptation.pdf},\n  publisher = {IEEE},\n  series = {ICSE-C '17},\n  title = {Fully-reflective VMs for Ruling Software Adaptation},\n  type = {Poster},\n  year = {2017},\n  month_numeric = {5}\n}\n"}, {"author"=>"Stefan Marr, Carmen Torres Lopez, Dominik Aumayr, Elisa Gonzalez Boix, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"C.", "last"=>"Torres Lopez"}, {"first"=>"D.", "last"=>"Aumayr"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"With the omnipresence of multicore processors, developers combine various concurrency abstractions such as actors, communicating sequential processes, or fork/join programming to utilize the available parallelism. Unfortunately, when we debug such systems today, we need to reason about low-level memory accesses, locks, and thread pools, because debuggers rarely know about actors, messages, channels, or fork/join tasks.\r\n\r\nWith Kómpos, we present a concurrent debugger that is designed to enable us to reason about our programs on the level of these abstractions. We will demonstrate some of the features of Kómpos and discuss the research challenges for building a concurrent debugger for a wide range of concurrency abstractions.", "title"=>"Kómpos: A Platform for Debugging Complex Concurrent Applications", "bibtype"=>"presentation", "type"=>"Demo", "journal"=>"", "year"=>"2017", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Companion to the First International Conference on the Art, Science and Engineering of Programming", "interhash"=>"9abcfadddac4f838ffbbf883d41bbde9", "publisher"=>"ACM", "series"=>"Programming Demo'17", "series_venue"=>"Programming Demo", "school"=>"", "doi"=>"10.1145/3079368.3079378", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/progdemo-marr-et-al-kompos-a-platform-for-debugging-complex-concurrent-applications.pdf", "pages"=>"2:1&ndash;2:2", "publication_date"=>"2 apr 2017", "bibtex"=>"@presentation{Marr:2017:KomposDemo,\n  abstract = {With the omnipresence of multicore processors, developers combine various concurrency abstractions such as actors, communicating sequential processes, or fork/join programming to utilize the available parallelism. Unfortunately, when we debug such systems today, we need to reason about low-level memory accesses, locks, and thread pools, because debuggers rarely know about actors, messages, channels, or fork/join tasks.\r\n  \r\n  With Kómpos, we present a concurrent debugger that is designed to enable us to reason about our programs on the level of these abstractions. We will demonstrate some of the features of Kómpos and discuss the research challenges for building a concurrent debugger for a wide range of concurrency abstractions.},\n  author = {Marr, Stefan and Torres Lopez, Carmen and Aumayr, Dominik and Gonzalez Boix, Elisa and Mössenböck, Hanspeter},\n  booktitle = {Companion to the First International Conference on the Art, Science and Engineering of Programming},\n  day = {2},\n  doi = {10.1145/3079368.3079378},\n  isbn = {978-1-4503-4836-2},\n  keywords = {Actors CSP Concurrency Debugger Kompos MeMyPublication STM SharedMemory myown},\n  month = apr,\n  pages = {2:1--2:2},\n  pdf = {http://stefan-marr.de/downloads/progdemo-marr-et-al-kompos-a-platform-for-debugging-complex-concurrent-applications.pdf},\n  publisher = {ACM},\n  series = {Programming Demo'17},\n  title = {{Kómpos: A Platform for Debugging Complex Concurrent Applications}},\n  type = {Demo},\n  year = {2017},\n  month_numeric = {4}\n}\n"}, {"author"=>"Carmen Torres Lopez, Stefan Marr, Hanspeter Mössenböck, Elisa Gonzalez Boix", "author_abbr_firstname"=>[{"first"=>"C.", "last"=>"Torres Lopez"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"H.", "last"=>"Mössenböck"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}], "abstract"=>"With the ubiquity of multicore hardware, concurrent and parallel programming has become a fundamental part of software development. If writing concurrent programs is hard, debugging them is even harder. The actor model is attractive for developing concurrent applications because actors are isolated concurrent entities that communicates through asynchronous message sending and do not share state, thus they avoid common concurrency bugs such as race conditions. However, they are not immune to bugs. This paper presents initial work on a taxonomy of concurrent bugs for actor-based applications. Based on this study, we propose debugging tooling to assist the development process of actor-based applications.", "title"=>"Towards Advanced Debugging Support for Actor Languages: Studying Concurrency Bugs in Actor-based Programs", "bibtype"=>"presentation", "type"=>"", "journal"=>"", "year"=>"2016", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Presentation at 6th International Workshop on Programming based on Actors, Agents, and Decentralized Control", "interhash"=>"0c12f719358d2728a5c41b9d0b2c218a", "publisher"=>"", "series"=>"AGERE! '16", "series_venue"=>"AGERE!", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/agere16-torres-lopez-et-al-towards-advanced-debugging-support-for-actor-languages.pdf", "pages"=>nil, "publication_date"=>"30 oct 2016", "bibtex"=>"@presentation{TorresLopez:2016:TAD,\n  abstract = {With the ubiquity of multicore hardware, concurrent and parallel programming has become a fundamental part of software development. If writing concurrent programs is hard, debugging them is even harder. The actor model is attractive for developing concurrent applications because actors are isolated concurrent entities that communicates through asynchronous message sending and do not share state, thus they avoid common concurrency bugs such as race conditions. However, they are not immune to bugs. This paper presents initial work on a taxonomy of concurrent bugs for actor-based applications. Based on this study, we propose debugging tooling to assist the development process of actor-based applications.},\n  author = {Torres Lopez, Carmen and Marr, Stefan and Mössenböck, Hanspeter and Gonzalez Boix, Elisa},\n  booktitle = {Presentation at 6th International Workshop on Programming based on Actors, Agents, and Decentralized Control},\n  day = {30},\n  keywords = {Bugs EventLoops MeMyPublication Messages Survey Vats actors concurrency debugging myown},\n  month = oct,\n  numpages = {5},\n  pdf = {http://stefan-marr.de/downloads/agere16-torres-lopez-et-al-towards-advanced-debugging-support-for-actor-languages.pdf},\n  series = {AGERE! '16},\n  title = {{Towards Advanced Debugging Support for Actor Languages: Studying Concurrency Bugs in Actor-based Programs}},\n  year = {2016},\n  month_numeric = {10}\n}\n"}, {"author"=>"Guido Chari, Diego Garbervetsky, Stefan Marr", "author_abbr_firstname"=>[{"first"=>"G.", "last"=>"Chari"}, {"first"=>"D.", "last"=>"Garbervetsky"}, {"first"=>"S.", "last"=>"Marr"}], "abstract"=>"Programming language virtual machines (VMs) realize language semantics, enforce security properties, and execute applications efficiently. Fully Reflective Execution Environments (EEs) are VMs that additionally expose their whole structure and behavior to applications. This enables developers to observe and adapt VMs at run time. However, there is a belief that reflective EEs are not viable for practical usages because such flexibility would incur a high performance overhead.\r\n\r\nTo refute this belief, we built a reflective EE on top of a highly optimizing dynamic compiler. We introduced a new optimization model that, based on the conjecture that variability of low-level (EE-level) reflective behavior is low in many scenarios, mitigates the most significant sources of the performance overheads related to the reflective capabilities in the EE. Our experiments indicate that reflective EEs can reach peak performance in the order of standard VMs. Concretely, that a) if reflective mechanisms are not used the execution overhead is negligible compared to standard VMs, b) VM operations can be redefined at language-level without incurring in significant overheads, c) for several software adaptation tasks, applying the reflection at the VM level is not only lightweight in terms of engineering effort, but also competitive in terms of performance in comparison to other ad-hoc solutions.", "title"=>"Building Efficient and Highly Run-time Adaptable Virtual Machines", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2016", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 12th Symposium on Dynamic Languages", "interhash"=>"66c1f1202ee6785cfa6a4edbd6d0f27f", "publisher"=>"ACM", "series"=>"DLS'16", "series_venue"=>"DLS", "school"=>"", "doi"=>"10.1145/2989225.2989234", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/dls16-chari-et-al-building-efficient-and-highly-run-time-adaptable-virtual-machines.pdf", "pages"=>"60&ndash;71", "publication_date"=>"1 nov 2016", "bibtex"=>"@inproceedings{Chari:2016:Mate2,\n  abstract = {Programming language virtual machines (VMs) realize language semantics, enforce security properties, and execute applications efficiently. Fully Reflective Execution Environments (EEs) are VMs that additionally expose their whole structure and behavior to applications. This enables developers to observe and adapt VMs at run time. However, there is a belief that reflective EEs are not viable for practical usages because such flexibility would incur a high performance overhead.\r\n  \r\n  To refute this belief, we built a reflective EE on top of a highly optimizing dynamic compiler. We introduced a new optimization model that, based on the conjecture that variability of low-level (EE-level) reflective behavior is low in many scenarios, mitigates the most significant sources of the performance overheads related to the reflective capabilities in the EE. Our experiments indicate that reflective EEs can reach peak performance in the order of standard VMs. Concretely, that a) if reflective mechanisms are not used the execution overhead is negligible compared to standard VMs, b) VM operations can be redefined at language-level without incurring in significant overheads, c) for several software adaptation tasks, applying the reflection at the VM level is not only lightweight in terms of engineering effort, but also competitive in terms of performance in comparison to other ad-hoc solutions.},\n  acceptancerate = {0.55},\n  author = {Chari, Guido and Garbervetsky, Diego and Marr, Stefan},\n  booktitle = {Proceedings of the 12th Symposium on Dynamic Languages},\n  day = {1},\n  doi = {10.1145/2989225.2989234},\n  isbn = {978-1-4503-4445-6},\n  keywords = {MOP Mate MeMyPublication MetaObjectProtocol Optimization Performance Study Truffle myown},\n  location = {Amsterdam, Netherlands},\n  month = nov,\n  note = {(acceptance rate 55%)},\n  numpages = {12},\n  pages = {60--71},\n  pdf = {http://stefan-marr.de/downloads/dls16-chari-et-al-building-efficient-and-highly-run-time-adaptable-virtual-machines.pdf},\n  publisher = {ACM},\n  series = {DLS'16},\n  title = {{Building Efficient and Highly Run-time Adaptable Virtual Machines}},\n  year = {2016},\n  month_numeric = {11}\n}\n"}, {"author"=>"Stefan Marr, Benoit Daloze, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"B.", "last"=>"Daloze"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"Comparing the performance of programming languages is difficult because they differ in many aspects including preferred programming abstractions, available frameworks, and their runtime systems. Nonetheless, the question about relative performance comes up repeatedly in the research community, industry, and wider audience of enthusiasts.\r\n\r\nThis paper presents 14 benchmarks and a novel methodology to assess the compiler effectiveness across language implementations. Using a set of common language abstractions, the benchmarks are implemented in Java, JavaScript, Ruby, Crystal, Newspeak, and Smalltalk. We show that the benchmarks exhibit a wide range of characteristics using language-agnostic metrics. Using four different languages on top of the same compiler, we show that the benchmarks perform similarly and therefore allow for a comparison of compiler effectiveness across languages. Based on anecdotes, we argue that these benchmarks help language implementers to identify performance bugs and optimization potential by comparing to other language implementations.", "title"=>"Cross-Language Compiler Benchmarking&mdash;Are We Fast Yet?", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2016", "blog"=>"http://stefan-marr.de/2016/10/cross-language-compiler-benchmarking-are-we-fast-yet/", "html"=>"http://stefan-marr.de/papers/dls-marr-et-al-cross-language-compiler-benchmarking-are-we-fast-yet/", "appendix"=>"https://github.com/smarr/are-we-fast-yet#readme", "booktitle"=>"Proceedings of the 12th Symposium on Dynamic Languages", "interhash"=>"b19a3027d653a0a8a59199c0f576571c", "publisher"=>"ACM", "series"=>"DLS'16", "series_venue"=>"DLS", "school"=>"", "doi"=>"10.1145/2989225.2989232", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/dls16-marr-et-al-cross-language-compiler-benchmarking-are-we-fast-yet.pdf", "pages"=>"120&ndash;131", "publication_date"=>"1 nov 2016", "bibtex"=>"@inproceedings{Marr:2016:AWFY,\n  abstract = {Comparing the performance of programming languages is difficult because they differ in many aspects including preferred programming abstractions, available frameworks, and their runtime systems. Nonetheless, the question about relative performance comes up repeatedly in the research community, industry, and wider audience of enthusiasts.\r\n  \r\n  This paper presents 14 benchmarks and a novel methodology to assess the compiler effectiveness across language implementations. Using a set of common language abstractions, the benchmarks are implemented in Java, JavaScript, Ruby, Crystal, Newspeak, and Smalltalk. We show that the benchmarks exhibit a wide range of characteristics using language-agnostic metrics. Using four different languages on top of the same compiler, we show that the benchmarks perform similarly and therefore allow for a comparison of compiler effectiveness across languages. Based on anecdotes, we argue that these benchmarks help language implementers to identify performance bugs and optimization potential by comparing to other language implementations.},\n  acceptancerate = {0.55},\n  appendix = {https://github.com/smarr/are-we-fast-yet#readme},\n  author = {Marr, Stefan and Daloze, Benoit and Mössenböck, Hanspeter},\n  blog = {http://stefan-marr.de/2016/10/cross-language-compiler-benchmarking-are-we-fast-yet/},\n  booktitle = {Proceedings of the 12th Symposium on Dynamic Languages},\n  day = {1},\n  doi = {10.1145/2989225.2989232},\n  html = {http://stefan-marr.de/papers/dls-marr-et-al-cross-language-compiler-benchmarking-are-we-fast-yet/},\n  isbn = {978-1-4503-4445-6},\n  keywords = {Benchmark Compiler Crystal Graal Java JavaScript MeMyPublication Metrics Newspeak NodeJS Performance Ruby Smalltalk Truffle myown},\n  location = {Amsterdam, Netherlands},\n  month = nov,\n  note = {(acceptance rate 55%)},\n  numpages = {12},\n  pages = {120--131},\n  pdf = {http://stefan-marr.de/downloads/dls16-marr-et-al-cross-language-compiler-benchmarking-are-we-fast-yet.pdf},\n  publisher = {ACM},\n  series = {DLS'16},\n  title = {{Cross-Language Compiler Benchmarking---Are We Fast Yet?}},\n  year = {2016},\n  month_numeric = {11}\n}\n"}, {"author"=>"Stefan Marr, Eric Jul", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"E.", "last"=>"Jul"}], "title"=>"Proceedings of the 11th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems", "bibtype"=>"proceedings", "type"=>"", "journal"=>"", "year"=>"2016", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"9cbd12d12e78a58daab28f6ddeaa089f", "publisher"=>"ACM", "series"=>"ICOOOLPS '16", "series_venue"=>"ICOOOLPS", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"jul 2016", "bibtex"=>"@proceedings{Marr:2016:ICOOOLPS,\n  author = {Marr, Stefan and Jul, Eric},\n  editor = {Marr, Stefan and Jul, Eric},\n  isbn = {978-1-4503-4837-9},\n  keywords = {MeMyPublication myown},\n  location = {Rome, Italy},\n  month = jul,\n  publisher = {ACM},\n  series = {ICOOOLPS '16},\n  title = {Proceedings of the 11th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems},\n  url = {http://dl.acm.org/citation.cfm?id=3012408},\n  year = {2016},\n  month_numeric = {7}\n}\n"}, {"author"=>"Daniele Bonetta, Luca Salucci, Stefan Marr, Walter Binder", "author_abbr_firstname"=>[{"first"=>"D.", "last"=>"Bonetta"}, {"first"=>"L.", "last"=>"Salucci"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"W.", "last"=>"Binder"}], "abstract"=>"JavaScript is the most popular programming language for client-side Web applications, and Node.js has popularized the language for server-side computing, too.\r\nIn this domain, the minimal support for parallel programming remains however a major limitation.\r\nIn this paper we introduce a novel parallel programming abstraction called Generic Messages (GEMs).\r\nGEMs allow one to combine message passing and shared-memory parallelism, extending the classes of parallel applications that can be built with Node.js.\r\nGEMs have customizable semantics and enable several forms of thread safety, isolation, and concurrency control.\r\nGEMs are designed as convenient JavaScript abstractions that expose high-level and safe parallelism models to the developer.\r\nExperiments show that GEMs outperform equivalent Node.js applications thanks to their usage of shared memory.", "title"=>"GEMs: Shared-memory Parallel Programming for Node.js", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2016", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 2016 ACM International Conference on Object Oriented Programming Systems Languages &amp; Applications", "interhash"=>"03ef98ec7bc5ec5346ad4e4daf7202f5", "publisher"=>"ACM", "series"=>"OOPSLA '16", "series_venue"=>"OOPSLA", "school"=>"", "doi"=>"10.1145/2983990.2984039", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/oopsla16-bonetta-et-al-gems-shared-memory-parallel-programming-for-nodejs.pdf", "pages"=>"531&ndash;547", "publication_date"=>"2 nov 2016", "bibtex"=>"@inproceedings{Bonetta:2016:GEMs,\n  abstract = {JavaScript is the most popular programming language for client-side Web applications, and Node.js has popularized the language for server-side computing, too.\r\n  In this domain, the minimal support for parallel programming remains however a major limitation.\r\n  In this paper we introduce a novel parallel programming abstraction called Generic Messages (GEMs).\r\n  GEMs allow one to combine message passing and shared-memory parallelism, extending the classes of parallel applications that can be built with Node.js.\r\n  GEMs have customizable semantics and enable several forms of thread safety, isolation, and concurrency control.\r\n  GEMs are designed as convenient JavaScript abstractions that expose high-level and safe parallelism models to the developer.\r\n  Experiments show that GEMs outperform equivalent Node.js applications thanks to their usage of shared memory.},\n  acceptancerate = {0.25},\n  author = {Bonetta, Daniele and Salucci, Luca and Marr, Stefan and Binder, Walter},\n  booktitle = {Proceedings of the 2016 ACM International Conference on Object Oriented Programming Systems Languages \\& Applications},\n  day = {2},\n  doi = {10.1145/2983990.2984039},\n  isbn = {978-1-4503-4444-9},\n  keywords = {Concurrency JavaScript MeMyPublication Messaging NodeJS Parallelism SharedMemory myown},\n  location = {Amsterdam, Netherlands},\n  month = nov,\n  note = {(acceptance rate 25%)},\n  numpages = {18},\n  pages = {531--547},\n  pdf = {http://stefan-marr.de/downloads/oopsla16-bonetta-et-al-gems-shared-memory-parallel-programming-for-nodejs.pdf},\n  publisher = {ACM},\n  series = {OOPSLA '16},\n  title = {{GEMs: Shared-memory Parallel Programming for Node.js}},\n  year = {2016},\n  month_numeric = {11}\n}\n"}, {"author"=>"Benoit Daloze, Stefan Marr, Daniele Bonetta, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"B.", "last"=>"Daloze"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"D.", "last"=>"Bonetta"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"We are in the multi-core era.\r\nDynamically-typed languages are in widespread use, but their support for\r\nmultithreading still lags behind. One of the reasons is that the sophisticated\r\ntechniques they use to efficiently represent their dynamic object models are\r\noften unsafe in multithreaded environments.\r\n\r\nThis paper defines safety requirements for dynamic object models in\r\nmultithreaded environments.\r\nBased on these requirements, a language-agnostic and thread-safe object model\r\nis designed that maintains the efficiency of sequential approaches.\r\nThis is achieved by ensuring that field reads do not require synchronization\r\nand field updates only need to synchronize on objects shared between threads.\r\n\r\nBasing our work on JRuby+Truffle, we show that our safe object model has zero overhead on peak performance for thread-local objects\r\nand only 3\\% average overhead on parallel benchmarks where field updates require synchronization.\r\nThus, it can be a foundation for safe and efficient multithreaded VMs for a wide range of dynamic languages.", "title"=>"Efficient and Thread-Safe Objects for Dynamically-Typed Languages", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2016", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 2016 ACM International Conference on Object Oriented Programming Systems Languages &amp; Applications", "interhash"=>"e308e02d9e1ea4c4e8187c56cd3770e8", "publisher"=>"ACM", "series"=>"OOPSLA '16", "series_venue"=>"OOPSLA", "school"=>"", "doi"=>"10.1145/2983990.2984001", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/oopsla16-daloze-et-al-efficient-and-thread-safe-objects-for-dynamically-typed-languages.pdf", "pages"=>"642&ndash;659", "publication_date"=>"2 nov 2016", "bibtex"=>"@inproceedings{Daloze:2016:TSO,\n  abstract = {We are in the multi-core era.\r\n  Dynamically-typed languages are in widespread use, but their support for\r\n  multithreading still lags behind. One of the reasons is that the sophisticated\r\n  techniques they use to efficiently represent their dynamic object models are\r\n  often unsafe in multithreaded environments.\r\n  \r\n  This paper defines safety requirements for dynamic object models in\r\n  multithreaded environments.\r\n  Based on these requirements, a language-agnostic and thread-safe object model\r\n  is designed that maintains the efficiency of sequential approaches.\r\n  This is achieved by ensuring that field reads do not require synchronization\r\n  and field updates only need to synchronize on objects shared between threads.\r\n  \r\n  Basing our work on JRuby+Truffle, we show that our safe object model has zero overhead on peak performance for thread-local objects\r\n  and only 3\\% average overhead on parallel benchmarks where field updates require synchronization.\r\n  Thus, it can be a foundation for safe and efficient multithreaded VMs for a wide range of dynamic languages.},\n  acceptancerate = {0.25},\n  author = {Daloze, Benoit and Marr, Stefan and Bonetta, Daniele and Mössenböck, Hanspeter},\n  booktitle = {Proceedings of the 2016 ACM International Conference on Object Oriented Programming Systems Languages \\& Applications},\n  day = {2},\n  doi = {10.1145/2983990.2984001},\n  isbn = {978-1-4503-4444-9},\n  keywords = {Bugs Concurrency HiddenClasses JRuby Map MeMyPublication ObjectModel ObjectStorage RaceConditions Ruby ThreadSafety myown},\n  month = nov,\n  note = {(acceptance rate 25%)},\n  numpages = {18},\n  pages = {642--659},\n  pdf = {http://stefan-marr.de/downloads/oopsla16-daloze-et-al-efficient-and-thread-safe-objects-for-dynamically-typed-languages.pdf},\n  publisher = {ACM},\n  series = {OOPSLA '16},\n  title = {{Efficient and Thread-Safe Objects for Dynamically-Typed Languages}},\n  year = {2016},\n  month_numeric = {11}\n}\n"}, {"author"=>"Luca Salucci, Daniele Bonetta, Stefan Marr, Walter Binder", "author_abbr_firstname"=>[{"first"=>"L.", "last"=>"Salucci"}, {"first"=>"D.", "last"=>"Bonetta"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"W.", "last"=>"Binder"}], "abstract"=>"Systems based on event-loops have been popularized by Node.JS, and are becoming a key technology in the domain of cloud computing. Despite their popularity, such systems support only share-nothing parallelism via message passing between parallel entities usually called workers. In this paper, we introduce a novel parallel programming abstraction called Generic Messages (GEMs), which enables shared-memory parallelism for share-nothing event-based systems. A key characteristic of GEMs is that they enable workers to share state by specifying how the state can be accessed once it is shared. We call this aspect of the GEMs model capability-based parallelism.", "title"=>"Generic Messages: Capability-based Shared Memory Parallelism for Event-loop Systems", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2016", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 21st ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming", "interhash"=>"edd3c26941aa2809420091a2380c438d", "publisher"=>"ACM", "series"=>"PPoPP Poster'16", "series_venue"=>"PPoPP Poster", "school"=>"", "doi"=>"10.1145/2851141.2851184", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/ppopp-salucci-et-al-generic-messages-capability-based-shared-memory-parallelism-for-event-loop-systems.pdf", "pages"=>"40:1&ndash;40:2", "publication_date"=>"mar 2016", "bibtex"=>"@inproceedings{Salucci:2016:GMC,\n  abstract = {Systems based on event-loops have been popularized by Node.JS, and are becoming a key technology in the domain of cloud computing. Despite their popularity, such systems support only share-nothing parallelism via message passing between parallel entities usually called workers. In this paper, we introduce a novel parallel programming abstraction called Generic Messages (GEMs), which enables shared-memory parallelism for share-nothing event-based systems. A key characteristic of GEMs is that they enable workers to share state by specifying how the state can be accessed once it is shared. We call this aspect of the GEMs model capability-based parallelism.},\n  acmid = {2851184},\n  articleno = {40},\n  author = {Salucci, Luca and Bonetta, Daniele and Marr, Stefan and Binder, Walter},\n  booktitle = {Proceedings of the 21st ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},\n  doi = {10.1145/2851141.2851184},\n  isbn = {978-1-4503-4092-2},\n  keywords = {Concurrency ECMAScript EventLoops JS JavaScript MOP MeMyPublication Parallelism Proxy SharedMemory myown},\n  location = {Barcelona, Spain},\n  month = mar,\n  numpages = {2},\n  pages = {40:1--40:2},\n  pdf = {http://stefan-marr.de/downloads/ppopp-salucci-et-al-generic-messages-capability-based-shared-memory-parallelism-for-event-loop-systems.pdf},\n  publisher = {ACM},\n  series = {PPoPP Poster'16},\n  title = {{Generic Messages: Capability-based Shared Memory Parallelism for Event-loop Systems}},\n  year = {2016},\n  month_numeric = {3}\n}\n"}, {"author"=>"Stefan Marr, Elisa Gonzalez Boix, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"E.", "last"=>"Gonzalez Boix"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"With the widespread use of multicore processors, software\r\nbecomes more and more diverse in its use of parallel computing\r\nresources. To address all application requirements, each with the\r\nappropriate abstraction, developers mix and match various\r\nconcurrency abstractions made available to them via libraries and\r\nframeworks. Unfortunately, today's tools such as debuggers and\r\nprofilers do not support the diversity of these abstractions.\r\nInstead of enabling developers to reason about the high-level\r\nprogramming concepts, they used to express their programs, the\r\ntools work only on the library's implementation level. While this\r\nis a common problem also for other libraries and frameworks, the\r\ncomplexity of concurrency exacerbates the issue further, and\r\nreasoning on the higher levels of the concurrency abstractions is\r\nessential to manage the associated complexity.\r\n\r\nIn this position paper, we identify open research issues and\r\npropose to build tools based on a common meta-level interface to\r\nenable developers to reasons about their programs based on the\r\nhigh-level concepts they used to implement them.", "title"=>"Towards Meta-Level Engineering and Tooling for Complex Concurrent Systems", "bibtype"=>"inproceedings", "type"=>"Position Paper", "journal"=>"", "year"=>"2016", "blog"=>"http://stefan-marr.de/2016/01/towards-meta-level-engineering-and-tooling-for-complex-concurrent-systems/", "html"=>"http://stefan-marr.de/papers/atps-marr-et-al-towards-meta-level-engineering-and-tooling-for-complex-concurrent-systems/", "appendix"=>"", "booktitle"=>"Proceedings of the 9th Arbeitstagung Programmiersprachen", "interhash"=>"b0599561ea7514193ff3fa9a93eec376", "publisher"=>"CEUR-WS", "series"=>"ATPS'16", "series_venue"=>"ATPS", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/atps-marr-et-al-towards-meta-level-engineering-and-tooling-for-complex-concurrent-systems.pdf", "pages"=>"91&ndash;95", "publication_date"=>"25 feb 2016", "bibtex"=>"@inproceedings{Marr:2016:MetaConc,\n  abstract = {With the widespread use of multicore processors, software\r\n  becomes more and more diverse in its use of parallel computing\r\n  resources. To address all application requirements, each with the\r\n  appropriate abstraction, developers mix and match various\r\n  concurrency abstractions made available to them via libraries and\r\n  frameworks. Unfortunately, today's tools such as debuggers and\r\n  profilers do not support the diversity of these abstractions.\r\n  Instead of enabling developers to reason about the high-level\r\n  programming concepts, they used to express their programs, the\r\n  tools work only on the library's implementation level. While this\r\n  is a common problem also for other libraries and frameworks, the\r\n  complexity of concurrency exacerbates the issue further, and\r\n  reasoning on the higher levels of the concurrency abstractions is\r\n  essential to manage the associated complexity.\r\n  \r\n  In this position paper, we identify open research issues and\r\n  propose to build tools based on a common meta-level interface to\r\n  enable developers to reasons about their programs based on the\r\n  high-level concepts they used to implement them.},\n  author = {Marr, Stefan and Gonzalez Boix, Elisa and Mössenböck, Hanspeter},\n  blog = {http://stefan-marr.de/2016/01/towards-meta-level-engineering-and-tooling-for-complex-concurrent-systems/},\n  booktitle = {Proceedings of the 9th Arbeitstagung Programmiersprachen},\n  day = {25},\n  html = {http://stefan-marr.de/papers/atps-marr-et-al-towards-meta-level-engineering-and-tooling-for-complex-concurrent-systems/},\n  issn = {1613-0073},\n  keywords = {Abstraction Concepts Concurrency HighLevel MeMyPublication MetaEngineering MetaLevel MetaProgramming Parallelism Profiling Representation Tooling myown},\n  location = {Vienna, Austria},\n  month = feb,\n  pages = {91--95},\n  pdf = {http://stefan-marr.de/downloads/atps-marr-et-al-towards-meta-level-engineering-and-tooling-for-complex-concurrent-systems.pdf},\n  publisher = {CEUR-WS},\n  series = {ATPS'16},\n  title = {Towards Meta-Level Engineering and Tooling for Complex Concurrent Systems},\n  type = {Position Paper},\n  url = {http://stefan-marr.de/papers/atps-marr-et-al-towards-meta-level-engineering-and-tooling-for-complex-concurrent-systems/},\n  volume = {1559},\n  year = {2016},\n  month_numeric = {2}\n}\n"}, {"author"=>"Joeri De Koster, Stefan Marr, Tom Van Cutsem, Theo D'Hondt", "author_abbr_firstname"=>[{"first"=>"J.", "last"=>"De Koster"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"Van Cutsem"}, {"first"=>"T.", "last"=>"D'Hondt"}], "abstract"=>"The actor model is a message-passing concurrency model that avoids deadlocks and low-level data races by construction. This facilitates concurrent programming, especially in the context of complex interactive applications where modularity, security and fault-tolerance are required. The tradeoff is that the actor model sacrifices expressiveness and safety guarantees with respect to parallel access to shared state. In this paper we present domains as a set of novel language abstractions for safely encapsulating and sharing state within the actor model. We introduce four types of domains, namely immutable, isolated, observable and shared domains that each are tailored to a certain access pattern on that shared state. The domains are characterized with an operational semantics. For each we discuss how the actor model's safety guarantees are upheld even in the presence of conceptually shared state. Furthermore, the proposed language abstractions are evaluated with a case study in Scala comparing them to other synchonisation mechanisms to demonstrate their benefits in deadlock freedom, parallel reads, and enforced isolation. ", "title"=>"Domains: Sharing State in the Communicating Event-Loop Actor Model", "bibtype"=>"article", "type"=>"", "journal"=>"Computer Languages, Systems & Structures", "year"=>"2016", "blog"=>"http://stefan-marr.de/2016/02/domains-sharing-state-in-the-communicating-event-loop-actor-model/", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"3adbb692105fd701eebdc50807bb2c44", "publisher"=>"Elsevier", "series"=>"ComLan", "series_venue"=>"ComLan", "school"=>"", "doi"=>"10.1016/j.cl.2016.01.003", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/comlan-de-koster-et-al-domains-sharing-state-in-the-communicating-event-loop-actor-model.pdf", "pages"=>"132&ndash;160", "publication_date"=>"apr 2016", "bibtex"=>"@article{DeKoster2016,\n  abstract = {The actor model is a message-passing concurrency model that avoids deadlocks and low-level data races by construction. This facilitates concurrent programming, especially in the context of complex interactive applications where modularity, security and fault-tolerance are required. The tradeoff is that the actor model sacrifices expressiveness and safety guarantees with respect to parallel access to shared state. In this paper we present domains as a set of novel language abstractions for safely encapsulating and sharing state within the actor model. We introduce four types of domains, namely immutable, isolated, observable and shared domains that each are tailored to a certain access pattern on that shared state. The domains are characterized with an operational semantics. For each we discuss how the actor model's safety guarantees are upheld even in the presence of conceptually shared state. Furthermore, the proposed language abstractions are evaluated with a case study in Scala comparing them to other synchonisation mechanisms to demonstrate their benefits in deadlock freedom, parallel reads, and enforced isolation. },\n  author = {De Koster, Joeri and Marr, Stefan and Van Cutsem, Tom and D'Hondt, Theo},\n  blog = {http://stefan-marr.de/2016/02/domains-sharing-state-in-the-communicating-event-loop-actor-model/},\n  doi = {10.1016/j.cl.2016.01.003},\n  issn = {1477-8424},\n  journal = {Computer Languages, Systems & Structures },\n  keywords = {Actors Concurrency Domains EventLoops Interpreter MeMyPublication Parallelism Shacl myown},\n  month = apr,\n  numpages = {39},\n  pages = {132-160},\n  pdf = {http://stefan-marr.de/downloads/comlan-de-koster-et-al-domains-sharing-state-in-the-communicating-event-loop-actor-model.pdf},\n  publisher = {Elsevier},\n  series = {ComLan},\n  title = {Domains: Sharing State in the Communicating Event-Loop Actor Model},\n  volume = {45},\n  year = {2016},\n  month_numeric = {4}\n}\n"}, {"author"=>"Mattias De Wael, Stefan Marr, Joeri De Koster, Jennifer B. Sartor, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"De Wael"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"J.", "last"=>"De Koster"}, {"first"=>"J., B.", "last"=>"Sartor"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"Today, software engineering practices focus on finding the single right data representation (i.e., data structure) for a program. The right data representation, however, might not exist: relying on a single representation of the data for the lifetime of the program can be suboptimal in terms of performance. We explore the idea of developing data structures for which changing the data representation is an intrinsic property. To this end we introduce Just-in-Time Data Structures, which enable representation changes at runtime, based on declarative input from a performance expert programmer. Just-in-Time Data Structures are an attempt to shift the focus from finding the ``right’’ data structure to finding the right sequence of data representations. We present JitDS-Java, an extension to the Java language, to develop Just-in-Time Data Structures. Further, we show two example programs that benefit from changing the representation at runtime.", "title"=>"Just-in-Time Data Structures", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2015", "blog"=>"http://stefan-marr.de/2015/10/jit-data-structures-fully-reflective-vms-and-meta-circular-meta-tracing/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming &amp; Software", "interhash"=>"ca767ff263c76e39ba25305e658771f5", "publisher"=>"ACM", "series"=>"Onward! '15", "series_venue"=>"Onward!", "school"=>"", "doi"=>"10.1145/2814228.2814231", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/onward15-de-wael-et-al-just-in-time-data-structures.pdf", "pages"=>"61&ndash;75", "publication_date"=>"oct 2015", "bibtex"=>"@inproceedings{DeWael:15:JitData,\n  abstract = {Today, software engineering practices focus on finding the single right data representation (i.e., data structure) for a program. The right data representation, however, might not exist: relying on a single representation of the data for the lifetime of the program can be suboptimal in terms of performance. We explore the idea of developing data structures for which changing the data representation is an intrinsic property. To this end we introduce Just-in-Time Data Structures, which enable representation changes at runtime, based on declarative input from a performance expert programmer. Just-in-Time Data Structures are an attempt to shift the focus from finding the ``right’’ data structure to finding the right sequence of data representations. We present JitDS-Java, an extension to the Java language, to develop Just-in-Time Data Structures. Further, we show two example programs that benefit from changing the representation at runtime.},\n  author = {De Wael, Mattias and Marr, Stefan and De Koster, Joeri and Sartor, Jennifer B. and De Meuter, Wolfgang},\n  blog = {http://stefan-marr.de/2015/10/jit-data-structures-fully-reflective-vms-and-meta-circular-meta-tracing/},\n  booktitle = {Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \\& Software},\n  doi = {10.1145/2814228.2814231},\n  isbn = {978-1-4503-3688-8},\n  keywords = {Algorithms DataStructures DynamicReclassification MeMyPublication Optimizations Performance myown},\n  location = {Pittsburgh, PA, USA},\n  month = oct,\n  numpages = {15},\n  pages = {61--75},\n  pdf = {http://stefan-marr.de/downloads/onward15-de-wael-et-al-just-in-time-data-structures.pdf},\n  publisher = {ACM},\n  series = {Onward! '15},\n  title = {Just-in-Time Data Structures},\n  url = {http://soft.vub.ac.be/~madewael/jitds/},\n  year = {2015},\n  month_numeric = {10}\n}\n"}, {"author"=>"Guido Chari, Diego Garbervetsky, Stefan Marr, Stéphane Ducasse", "author_abbr_firstname"=>[{"first"=>"G.", "last"=>"Chari"}, {"first"=>"D.", "last"=>"Garbervetsky"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"S.", "last"=>"Ducasse"}], "abstract"=>"Modern development environments promote live programming (LP) mechanisms because it enhances the development experience by providing instantaneous feed- back and interaction with live objects. LP is typically supported with advanced reflective techniques within dynamic languages. These languages run on top of Virtual Machines (VMs) that are built in a static manner so that most of their components are bound at compile time. As a consequence, VM developers are forced to work using the traditional edit-compile-run cycle, even when they are designing LP-supporting environments. In this paper we explore the idea of bringing LP techniques to the VM domain for improving their observability, evolution and adaptability at run-time. We define the notion of fully reflective execution environments (EEs), systems that provide reflection not only at the application level but also at the level of the VM. We characterize such systems, propose a design, and present Mate v1, a prototypical implementation. Based on our prototype, we analyze the feasibility and applicability of incorporating reflective capabilities into different parts of EEs. Furthermore, the evaluation demonstrates the opportunities such reflective capabilities provide for unanticipated dynamic adaptation scenarios, benefiting thus, a wider range of users.", "title"=>"Towards Fully Reflective Environments", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2015", "blog"=>"http://stefan-marr.de/2015/10/jit-data-structures-fully-reflective-vms-and-meta-circular-meta-tracing/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming &amp; Software", "interhash"=>"360e220beb08b9d61c893249074dd412", "publisher"=>"ACM", "series"=>"Onward! '15", "series_venue"=>"Onward!", "school"=>"", "doi"=>"10.1145/2814228.2814241", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/onward15-chari-et-al-towards-fully-reflective-environments.pdf", "pages"=>"240&ndash;253", "publication_date"=>"oct 2015", "bibtex"=>"@inproceedings{Chari:15:Mate,\n  abstract = {Modern development environments promote live programming (LP) mechanisms because it enhances the development experience by providing instantaneous feed- back and interaction with live objects. LP is typically supported with advanced reflective techniques within dynamic languages. These languages run on top of Virtual Machines (VMs) that are built in a static manner so that most of their components are bound at compile time. As a consequence, VM developers are forced to work using the traditional edit-compile-run cycle, even when they are designing LP-supporting environments. In this paper we explore the idea of bringing LP techniques to the VM domain for improving their observability, evolution and adaptability at run-time. We define the notion of fully reflective execution environments (EEs), systems that provide reflection not only at the application level but also at the level of the VM. We characterize such systems, propose a design, and present Mate v1, a prototypical implementation. Based on our prototype, we analyze the feasibility and applicability of incorporating reflective capabilities into different parts of EEs. Furthermore, the evaluation demonstrates the opportunities such reflective capabilities provide for unanticipated dynamic adaptation scenarios, benefiting thus, a wider range of users.},\n  author = {Chari, Guido and Garbervetsky, Diego and Marr, Stefan and Ducasse, Stéphane},\n  blog = {http://stefan-marr.de/2015/10/jit-data-structures-fully-reflective-vms-and-meta-circular-meta-tracing/},\n  booktitle = {Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \\& Software},\n  doi = {10.1145/2814228.2814241},\n  isbn = {978-1-4503-3688-8},\n  keywords = {DynamicAdaptation LiveProgramming MOP Mate MeMyPublication MetaObjectProtocols Reflection VirtualMachines myown},\n  location = {Pittsburgh, PA, USA},\n  month = oct,\n  numpages = {14},\n  pages = {240--253},\n  pdf = {http://stefan-marr.de/downloads/onward15-chari-et-al-towards-fully-reflective-environments.pdf},\n  publisher = {ACM},\n  series = {Onward! '15},\n  title = {Towards Fully Reflective Environments},\n  year = {2015},\n  month_numeric = {10}\n}\n"}, {"author"=>"Maarten Vandercammen, Jens Nicolay, Stefan Marr, Joeri De Koster, Theo D'Hondt, Coen De Roover", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"Vandercammen"}, {"first"=>"J.", "last"=>"Nicolay"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"J.", "last"=>"De Koster"}, {"first"=>"T.", "last"=>"D'Hondt"}, {"first"=>"C.", "last"=>"De Roover"}], "abstract"=>"Trace-based JIT compilers identify frequently executed program paths at run-time and subsequently record, compile and optimize their execution. In order to improve the performance of the generated machine instructions, JIT compilers heavily rely on dynamic analysis of the code. Existing work treats the components of a JIT compiler as a monolithic whole, tied to particular execution semantics. We propose a formal framework that facilitates the design and implementation of a tracing JIT compiler and its accompanying dynamic analyses by decoupling the tracing, optimization, and interpretation processes. This results in a framework that is more configurable and extensible than existing formal tracing models. We formalize the tracer and interpreter as two abstract state machines that communicate through a minimal, well-defined interface. Developing a tracing JIT compiler becomes possible for arbitrary interpreters that implement this interface. The abstract machines also provide the necessary hooks to plug in custom analyses and optimizations.", "title"=>"A Formal Foundation for Trace-Based JIT Compilers", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2015", "blog"=>"http://stefan-marr.de/2015/10/jit-data-structures-fully-reflective-vms-and-meta-circular-meta-tracing/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 13th International Workshop on Dynamic Analysis", "interhash"=>"28d42ec8ccafdeee3a41395c56db4eb8", "publisher"=>"ACM", "series"=>"WODA '15", "series_venue"=>"WODA", "school"=>"", "doi"=>"10.1145/2823363.2823369", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/woda15-vandercammen-et-al-a-formal-foundation-for-trace-based-jit-compilers.pdf", "pages"=>"25&ndash;30", "publication_date"=>"oct 2015", "bibtex"=>"@inproceedings{Vandercammen:15:WODA,\n  abstract = {Trace-based JIT compilers identify frequently executed program paths at run-time and subsequently record, compile and optimize their execution. In order to improve the performance of the generated machine instructions, JIT compilers heavily rely on dynamic analysis of the code. Existing work treats the components of a JIT compiler as a monolithic whole, tied to particular execution semantics. We propose a formal framework that facilitates the design and implementation of a tracing JIT compiler and its accompanying dynamic analyses by decoupling the tracing, optimization, and interpretation processes. This results in a framework that is more configurable and extensible than existing formal tracing models. We formalize the tracer and interpreter as two abstract state machines that communicate through a minimal, well-defined interface. Developing a tracing JIT compiler becomes possible for arbitrary interpreters that implement this interface. The abstract machines also provide the necessary hooks to plug in custom analyses and optimizations.},\n  address = {Pittsburgh, PA, USA},\n  author = {Vandercammen, Maarten and Nicolay, Jens and Marr, Stefan and De Koster, Joeri and D'Hondt, Theo and De Roover, Coen},\n  blog = {http://stefan-marr.de/2015/10/jit-data-structures-fully-reflective-vms-and-meta-circular-meta-tracing/},\n  booktitle = {Proceedings of the 13th International Workshop on Dynamic Analysis},\n  doi = {10.1145/2823363.2823369},\n  keywords = {Compilation DynamicAnalysis JIT MeMyPublication OperationalSemantics Tracing myown},\n  month = oct,\n  numpages = {6},\n  pages = {25--30},\n  pdf = {http://stefan-marr.de/downloads/woda15-vandercammen-et-al-a-formal-foundation-for-trace-based-jit-compilers.pdf},\n  publisher = {ACM},\n  series = {WODA '15},\n  title = {A Formal Foundation for Trace-Based JIT Compilers},\n  year = {2015},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr, Hanspeter Mössenböck", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"H.", "last"=>"Mössenböck"}], "abstract"=>"Communicating Event-Loop Languages similar to E and AmbientTalk are recently gaining more traction as a subset of actor languages. With the rise of JavaScript, E’s notion of vats and non-blocking communication based on promises entered the mainstream. For implementations, the combination of dynamic typing, asynchronous message sending, and promise resolution pose new optimization challenges.\r\n\r\nThis paper discusses these challenges and presents initial experiments for a Newspeak implementation based on the Truffle framework. Our implementation is on average 1.65x slower than Java on a set of 14 benchmarks. Initial optimizations improve the performance of asynchronous messages and reduce the cost of encapsulation on microbenchmarks by about 2x. Parallel actor benchmarks further show that the system scales based on the workload characteristics. Thus, we conclude that Truffle is a promising platform also for communicating event-loop languages.", "title"=>"Optimizing Communicating Event-Loop Languages with Truffle", "bibtype"=>"presentation", "type"=>"Work-in-Progress-Paper", "journal"=>"", "year"=>"2015", "blog"=>"http://stefan-marr.de/2015/10/optimizing-communicating-event-loop-languages-with-truffle/", "html"=>"http://stefan-marr.de/papers/agere-marr-moessenboeck-optimizing-communicating-event-loop-languages-with-truffle/", "appendix"=>"", "booktitle"=>"Presentation at 5th International Workshop on Programming based on Actors, Agents, and Decentralized Control", "interhash"=>"0a0937a8e45344c88cbe6fb1ad8c42fa", "publisher"=>"", "series"=>"AGERE!'15", "series_venue"=>"AGERE!", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/agere15-agere-marr-moessenboeck-optimizing-communicating-event-loop-languages-with-truffle.pdf", "pages"=>nil, "publication_date"=>"26 oct 2015", "bibtex"=>"@presentation{OptCELWithTruffle,\n  abstract = {Communicating Event-Loop Languages similar to E and AmbientTalk are recently gaining more traction as a subset of actor languages. With the rise of JavaScript, E’s notion of vats and non-blocking communication based on promises entered the mainstream. For implementations, the combination of dynamic typing, asynchronous message sending, and promise resolution pose new optimization challenges.\r\n  \r\n  This paper discusses these challenges and presents initial experiments for a Newspeak implementation based on the Truffle framework. Our implementation is on average 1.65x slower than Java on a set of 14 benchmarks. Initial optimizations improve the performance of asynchronous messages and reduce the cost of encapsulation on microbenchmarks by about 2x. Parallel actor benchmarks further show that the system scales based on the workload characteristics. Thus, we conclude that Truffle is a promising platform also for communicating event-loop languages.},\n  author = {Marr, Stefan and Mössenböck, Hanspeter},\n  blog = {http://stefan-marr.de/2015/10/optimizing-communicating-event-loop-languages-with-truffle/},\n  booktitle = {Presentation at 5th International Workshop on Programming based on Actors, Agents, and Decentralized Control},\n  day = {26},\n  html = {http://stefan-marr.de/papers/agere-marr-moessenboeck-optimizing-communicating-event-loop-languages-with-truffle/},\n  keywords = {Actors Caching CommunicatingEventLoops Compiler Concurrency MeMyPublication Message Optimization PIC Sending Truffle myown},\n  location = {Pittsburgh, PA, USA},\n  month = oct,\n  pdf = {http://stefan-marr.de/downloads/agere15-agere-marr-moessenboeck-optimizing-communicating-event-loop-languages-with-truffle.pdf},\n  series = {AGERE!'15},\n  title = {Optimizing Communicating Event-Loop Languages with Truffle},\n  type = {Work-in-Progress-Paper},\n  year = {2015},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr, Stéphane Ducasse", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"S.", "last"=>"Ducasse"}], "abstract"=>"Tracing and partial evaluation have been proposed as meta-compilation techniques for interpreters to make just-in-time compilation language-independent. They promise that programs executing on simple interpreters can reach performance of the same order of magnitude as if they would be executed on state-of-the-art virtual machines with highly optimizing just-in-time compilers built for a specific language. Tracing and partial evaluation approach this meta-compilation from two ends of a spectrum, resulting in different sets of tradeoffs.\r\n\r\nThis study investigates both approaches in the context of self-optimizing interpreters, a technique for building fast abstract-syntax-tree interpreters. Based on RPython for tracing and Truffle for partial evaluation, we assess the two approaches by comparing the impact of various optimizations on the performance of an interpreter for SOM, an object-oriented dynamically-typed language. The goal is to determine whether either approach yields clear performance or engineering benefits. We find that tracing and partial evaluation both reach roughly the same level of performance. SOM based on meta-tracing is on average 3x slower than Java, while SOM based on partial evaluation is on average 2.3x slower than Java. With respect to the engineering, tracing has however significant benefits, because it requires language implementers to apply fewer optimizations to reach the same level of performance.", "title"=>"Tracing vs. Partial Evaluation: Comparing Meta-Compilation Approaches for Self-Optimizing Interpreters", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2015", "blog"=>"http://stefan-marr.de/2015/10/tracing-vs-partial-evaluation-comparing-meta-compilation-approaches-for-self-optimizing-interpreters/", "html"=>"http://stefan-marr.de/papers/oopsla-marr-ducasse-meta-tracing-vs-partial-evaluation/", "appendix"=>"http://stefan-marr.de/papers/oopsla-marr-ducasse-meta-tracing-vs-partial-evaluation-artifacts/", "booktitle"=>"Proceedings of the 2015 ACM International Conference on Object Oriented Programming Systems Languages &amp; Applications", "interhash"=>"626a639666ea884d5b1a8dc121e8457a", "publisher"=>"ACM", "series"=>"OOPSLA '15", "series_venue"=>"OOPSLA", "school"=>"", "doi"=>"10.1145/2814270.2814275", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/oopsla15-marr-ducasse-meta-tracing-vs-partial-evaluation.pdf", "pages"=>"821&ndash;839", "publication_date"=>"oct 2015", "bibtex"=>"@inproceedings{Marr:2015:MTPE,\n  abstract = {Tracing and partial evaluation have been proposed as meta-compilation techniques for interpreters to make just-in-time compilation language-independent. They promise that programs executing on simple interpreters can reach performance of the same order of magnitude as if they would be executed on state-of-the-art virtual machines with highly optimizing just-in-time compilers built for a specific language. Tracing and partial evaluation approach this meta-compilation from two ends of a spectrum, resulting in different sets of tradeoffs.\r\n  \r\n  This study investigates both approaches in the context of self-optimizing interpreters, a technique for building fast abstract-syntax-tree interpreters. Based on RPython for tracing and Truffle for partial evaluation, we assess the two approaches by comparing the impact of various optimizations on the performance of an interpreter for SOM, an object-oriented dynamically-typed language. The goal is to determine whether either approach yields clear performance or engineering benefits. We find that tracing and partial evaluation both reach roughly the same level of performance. SOM based on meta-tracing is on average 3x slower than Java, while SOM based on partial evaluation is on average 2.3x slower than Java. With respect to the engineering, tracing has however significant benefits, because it requires language implementers to apply fewer optimizations to reach the same level of performance.},\n  acceptancerate = {0.25},\n  acmid = {2660194},\n  appendix = {http://stefan-marr.de/papers/oopsla-marr-ducasse-meta-tracing-vs-partial-evaluation-artifacts/},\n  author = {Marr, Stefan and Ducasse, Stéphane},\n  blog = {http://stefan-marr.de/2015/10/tracing-vs-partial-evaluation-comparing-meta-compilation-approaches-for-self-optimizing-interpreters/},\n  booktitle = {Proceedings of the 2015 ACM International Conference on Object Oriented Programming Systems Languages \\& Applications},\n  doi = {10.1145/2814270.2814275},\n  html = {http://stefan-marr.de/papers/oopsla-marr-ducasse-meta-tracing-vs-partial-evaluation/},\n  isbn = {978-1-4503-2585-1},\n  keywords = {Compiler Interpreter JITCompilation MeMyPublication MetaTracing Optimization PartialEvaluation RPython SelfOptimizing Tracing Truffle myown},\n  month = oct,\n  note = {(acceptance rate 25%)},\n  numpages = {19},\n  pages = {821--839},\n  pdf = {http://stefan-marr.de/downloads/oopsla15-marr-ducasse-meta-tracing-vs-partial-evaluation.pdf},\n  publisher = {ACM},\n  series = {OOPSLA '15},\n  title = {Tracing vs. Partial Evaluation: Comparing Meta-Compilation Approaches for Self-Optimizing Interpreters},\n  year = {2015},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr, Chris Seaton, Stéphane Ducasse", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"C.", "last"=>"Seaton"}, {"first"=>"S.", "last"=>"Ducasse"}], "abstract"=>"Runtime metaprogramming enables many useful applications and is often a convenient solution to solve problems in a generic way, which makes it widely used in frameworks, middleware, and domain-specific languages. However, powerful metaobject protocols are rarely supported and even common concepts such as reflective method invocation or dynamic proxies are not optimized. Solutions proposed in literature either restrict the metaprogramming capabilities or require application or library developers to apply performance improving techniques.\r\n\r\nFor overhead-free runtime metaprogramming, we demonstrate that dispatch chains, a generalized form of polymorphic inline caches common to self-optimizing interpreters, are a simple optimization at the language-implementation level. Our evaluation with self-optimizing interpreters shows that unrestricted metaobject protocols can be realized for the first time without runtime overhead, and that this optimization is applicable for just-in-time compilation of interpreters based on meta-tracing as well as partial evaluation. In this context, we also demonstrate that optimizing common reflective operations can lead to significant performance improvements for existing applications.", "title"=>"Zero-Overhead Metaprogramming: Reflection and Metaobject Protocols Fast and without Compromises", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2015", "blog"=>"http://stefan-marr.de/2015/04/zero-overhead-metaprogramming/", "html"=>"http://stefan-marr.de/papers/pldi-marr-et-al-zero-overhead-metaprogramming/", "appendix"=>"http://stefan-marr.de/papers/pldi-marr-et-al-zero-overhead-metaprogramming-artifacts/", "booktitle"=>"Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation", "interhash"=>"c212198ae76c6205f6cdbf31185dcc1c", "publisher"=>"ACM", "series"=>"PLDI '15", "series_venue"=>"PLDI", "school"=>"", "doi"=>"10.1145/2737924.2737963", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/pldi15-marr-et-al-zero-overhead-metaprogramming.pdf", "pages"=>"545&ndash;554", "publication_date"=>"jun 2015", "bibtex"=>"@inproceedings{ZeroOverhead,\n  abstract = {Runtime metaprogramming enables many useful applications and is often a convenient solution to solve problems in a generic way, which makes it widely used in frameworks, middleware, and domain-specific languages. However, powerful metaobject protocols are rarely supported and even common concepts such as reflective method invocation or dynamic proxies are not optimized. Solutions proposed in literature either restrict the metaprogramming capabilities or require application or library developers to apply performance improving techniques.\r\n  \r\n  For overhead-free runtime metaprogramming, we demonstrate that dispatch chains, a generalized form of polymorphic inline caches common to self-optimizing interpreters, are a simple optimization at the language-implementation level. Our evaluation with self-optimizing interpreters shows that unrestricted metaobject protocols can be realized for the first time without runtime overhead, and that this optimization is applicable for just-in-time compilation of interpreters based on meta-tracing as well as partial evaluation. In this context, we also demonstrate that optimizing common reflective operations can lead to significant performance improvements for existing applications.},\n  appendix = {http://stefan-marr.de/papers/pldi-marr-et-al-zero-overhead-metaprogramming-artifacts/},\n  author = {Marr, Stefan and Seaton, Chris and Ducasse, Stéphane},\n  blog = {http://stefan-marr.de/2015/04/zero-overhead-metaprogramming/},\n  booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},\n  doi = {10.1145/2737924.2737963},\n  html = {http://stefan-marr.de/papers/pldi-marr-et-al-zero-overhead-metaprogramming/},\n  isbn = {978-1-4503-3468-6},\n  keywords = {DispatchChains MeMyPublication MetaProgramming Overhead Performance RPython Truffle myown},\n  month = jun,\n  note = {(acceptance rate 19%)},\n  numpages = {10},\n  pages = {545--554},\n  pdf = {http://stefan-marr.de/downloads/pldi15-marr-et-al-zero-overhead-metaprogramming.pdf},\n  publisher = {ACM},\n  series = {PLDI '15},\n  title = {Zero-Overhead Metaprogramming: Reflection and Metaobject Protocols Fast and without Compromises},\n  year = {2015},\n  month_numeric = {6}\n}\n"}, {"author"=>"Mattias De Wael, Stefan Marr, Bruno De Fraine, Tom Van Cutsem, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"De Wael"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"B.", "last"=>"De Fraine"}, {"first"=>"T.", "last"=>"Van Cutsem"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"The Partitioned Global Address Space (PGAS) model is a parallel programming model that aims to improve programmer productivity while at the same time aiming for high performance. The main premise of PGAS is that a globally shared address space improves productivity, but that a distinction between local and remote data accesses is required to allow performance optimizations and to support scalability on large-scale parallel architectures. To this end, PGAS preserves the global address space while embracing awareness of non-uniform communication costs.\r\n\r\nToday, about a dozen languages exist that adhere to the PGAS model. This survey proposes a definition and a taxonomy along four axes: how parallelism is introduced, how the address space is partitioned, how data is distributed among the partitions and finally how data is accessed across partitions. Our taxonomy reveals that today's PGAS languages focus on distributing regular data and distinguish only between local and remote data access cost, whereas the distribution of irregular data and the adoption of richer data access cost models remain open challenges.", "title"=>"Partitioned Global Address Space Languages", "bibtype"=>"article", "type"=>"", "journal"=>"ACM Computing Surveys", "year"=>"2015", "blog"=>"http://stefan-marr.de/2015/01/partitioned-global-address-space-languages/", "html"=>"http://stefan-marr.de/papers/acm-csur-de-wael-et-al-partitioned-global-address-space-languages/", "appendix"=>"", "booktitle"=>"", "interhash"=>"e0e73b5f03d2594bbf77e7b648bac11e", "publisher"=>"ACM", "series"=>"ACM CSUR", "series_venue"=>"ACM CSUR", "school"=>"", "doi"=>"10.1145/2716320", "howpublished"=>"", "number"=>"4", "pdf"=>"http://stefan-marr.de/downloads/acm-csur-de-wael-et-al-partitioned-global-address-space-languages.pdf", "pages"=>"62:1&ndash;62:27", "publication_date"=>"jun 2015", "bibtex"=>"@article{PGASSurvey,\n  abstract = {The Partitioned Global Address Space (PGAS) model is a parallel programming model that aims to improve programmer productivity while at the same time aiming for high performance. The main premise of PGAS is that a globally shared address space improves productivity, but that a distinction between local and remote data accesses is required to allow performance optimizations and to support scalability on large-scale parallel architectures. To this end, PGAS preserves the global address space while embracing awareness of non-uniform communication costs.\r\n  \r\n  Today, about a dozen languages exist that adhere to the PGAS model. This survey proposes a definition and a taxonomy along four axes: how parallelism is introduced, how the address space is partitioned, how data is distributed among the partitions and finally how data is accessed across partitions. Our taxonomy reveals that today's PGAS languages focus on distributing regular data and distinguish only between local and remote data access cost, whereas the distribution of irregular data and the adoption of richer data access cost models remain open challenges.},\n  articleno = {62},\n  author = {De Wael, Mattias and Marr, Stefan and De Fraine, Bruno and Van Cutsem, Tom and De Meuter, Wolfgang},\n  blog = {http://stefan-marr.de/2015/01/partitioned-global-address-space-languages/},\n  doi = {10.1145/2716320},\n  html = {http://stefan-marr.de/papers/acm-csur-de-wael-et-al-partitioned-global-address-space-languages/},\n  impactfactor2014 = {3.373},\n  impactfactor5y2014 = {5.949},\n  issn = {0360-0300},\n  journal = {ACM Computing Surveys},\n  keywords = {Concurrency GlobalAddressSpace HPC LanguageDesign MeMyPublication MessagePassing PGAS Parallelism Performance SharedMemory myown},\n  month = jun,\n  number = {4},\n  numpages = {27},\n  pages = {62:1--62:27},\n  pdf = {http://stefan-marr.de/downloads/acm-csur-de-wael-et-al-partitioned-global-address-space-languages.pdf},\n  publisher = {ACM},\n  series = {ACM CSUR},\n  title = {Partitioned Global Address Space Languages},\n  volume = {47},\n  year = {2015},\n  month_numeric = {6}\n}\n"}, {"author"=>"Stefan Marr, Tobias Pape, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"Pape"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"Research on language implementation techniques has regained importance with the rise of domain-specific languages (DSLs). Although DSLs can help manage a domain’s complexity, building highly optimizing compilers or virtual machines is rarely affordable. So, performance remains an issue. Ideally, you would implement a simple interpreter and still be able to achieve acceptable performance. RPython and Truffle are implementation techniques based on simple interpreters; they promise to perform at the same order of magnitude as highly optimizing virtual machines. This case study compares the two techniques to identify their similarities, weaknesses, and areas for further research.", "title"=>"Are We There Yet? Simple Language Implementation Techniques for the 21st Century", "bibtype"=>"article", "type"=>"", "journal"=>"IEEE Software", "year"=>"2014", "blog"=>"http://stefan-marr.de/2014/09/are-we-there-yet/", "html"=>"http://stefan-marr.de/papers/ieee-soft-marr-et-al-are-we-there-yet/", "appendix"=>"http://stefan-marr.de/papers/ieee-soft-marr-et-al-appendix-performance-evaluation/", "booktitle"=>"", "interhash"=>"cf1741034f10e8abf2bfe2a9e30ebbc5", "publisher"=>"", "series"=>"IEEE Soft", "series_venue"=>"IEEE Soft", "school"=>"", "doi"=>"10.1109/MS.2014.98", "howpublished"=>"", "number"=>"5", "pdf"=>"http://stefan-marr.de/downloads/ieee-soft-marr-et-al-are-we-there-yet.pdf", "pages"=>"60&ndash;67", "publication_date"=>"15 sep 2014", "bibtex"=>"@article{marr2014there,\n  abstract = {Research on language implementation techniques has regained importance with the rise of domain-specific languages (DSLs). Although DSLs can help manage a domain’s complexity, building highly optimizing compilers or virtual machines is rarely affordable. So, performance remains an issue. Ideally, you would implement a simple interpreter and still be able to achieve acceptable performance. RPython and Truffle are implementation techniques based on simple interpreters; they promise to perform at the same order of magnitude as highly optimizing virtual machines. This case study compares the two techniques to identify their similarities, weaknesses, and areas for further research.},\n  appendix = {http://stefan-marr.de/papers/ieee-soft-marr-et-al-appendix-performance-evaluation/},\n  author = {Marr, Stefan and Pape, Tobias and De Meuter, Wolfgang},\n  blog = {http://stefan-marr.de/2014/09/are-we-there-yet/},\n  day = {15},\n  doi = {10.1109/MS.2014.98},\n  html = {http://stefan-marr.de/papers/ieee-soft-marr-et-al-are-we-there-yet/},\n  impactfactor2014 = {1.053},\n  impactfactor5y2014 = {1.397},\n  issn = {0740-7459},\n  journal = {IEEE Software},\n  keywords = {Compilers ComputerProgramming DSL Interpreter Interpreters LanguageImplementation MeMyPublication Performance ProgrammingLanguages RPython SOM SelfOptimizing Smalltalk SoftwareEngineering Truffle VirtualMachines myown},\n  month = sep,\n  number = {5},\n  numpages = {8},\n  pages = {60--67},\n  pdf = {http://stefan-marr.de/downloads/ieee-soft-marr-et-al-are-we-there-yet.pdf},\n  series = {IEEE Soft},\n  title = {Are We There Yet? Simple Language Implementation Techniques for the 21st Century},\n  volume = {31},\n  year = {2014},\n  month_numeric = {9}\n}\n"}, {"author"=>"Mattias De Wael, Stefan Marr, Tom Van Cutsem", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"De Wael"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"Van Cutsem"}], "abstract"=>"Now that multicore processors are commonplace, developing parallel software has\r\nescaped the confines of high-performance computing and enters the mainstream.\r\nThe Fork/Join framework, for instance, is part of the standard Java platform\r\nsince version 7. Fork/Join is a high-level parallel programming model advocated\r\nto make parallelizing recursive divide-and-conquer algorithms particularly\r\neasy. While, in theory, Fork/Join is a simple and effective technique to expose\r\nparallelism in applications, it has not been investigated before whether and\r\nhow the technique is applied in practice. We therefore performed an empirical\r\nstudy on a corpus of 120 open source Java projects that use the framework for\r\nroughly 362 different tasks. On the one hand, we confirm the frequent use of\r\nfour best-practice patterns (Sequential Cutoff, Linked Subtasks, Leaf Tasks,\r\nand avoiding unnecessary forking) in actual projects. On the other hand, we\r\nalso discovered three recurring anti-patterns that potentially limit parallel\r\nperformance: sub-optimal use of Java collections when splitting tasks into\r\nsubtasks as well as when merging the results of subtasks, and finally the\r\ninappropriate sharing of resources between tasks. We document these\r\nanti-patterns and study their impact on performance.", "title"=>"Fork/Join Parallelism in the Wild: Documenting Patterns and Anti-Patterns in Java Programs using the Fork/Join Framework", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2014", "blog"=>"http://stefan-marr.de/2014/09/forkjoin-parallelism-in-the-wild/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools", "interhash"=>"6a67e3d8a05209a4aa4bc3b18dd49699", "publisher"=>"", "series"=>"ManLang'14", "series_venue"=>"ManLang", "school"=>"", "doi"=>"10.1145/2647508.2647511", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/pppj14-dewael-et-al-forkjoin-parallelism-in-the-wild.pdf", "pages"=>"39&ndash;50", "publication_date"=>"sep 2014", "bibtex"=>"@inproceedings{dewael2014forkjoin,\n  abstract = {Now that multicore processors are commonplace, developing parallel software has\r\n  escaped the confines of high-performance computing and enters the mainstream.\r\n  The Fork/Join framework, for instance, is part of the standard Java platform\r\n  since version 7. Fork/Join is a high-level parallel programming model advocated\r\n  to make parallelizing recursive divide-and-conquer algorithms particularly\r\n  easy. While, in theory, Fork/Join is a simple and effective technique to expose\r\n  parallelism in applications, it has not been investigated before whether and\r\n  how the technique is applied in practice. We therefore performed an empirical\r\n  study on a corpus of 120 open source Java projects that use the framework for\r\n  roughly 362 different tasks. On the one hand, we confirm the frequent use of\r\n  four best-practice patterns (Sequential Cutoff, Linked Subtasks, Leaf Tasks,\r\n  and avoiding unnecessary forking) in actual projects. On the other hand, we\r\n  also discovered three recurring anti-patterns that potentially limit parallel\r\n  performance: sub-optimal use of Java collections when splitting tasks into\r\n  subtasks as well as when merging the results of subtasks, and finally the\r\n  inappropriate sharing of resources between tasks. We document these\r\n  anti-patterns and study their impact on performance.},\n  acceptancerate = {0.39},\n  author = {De Wael, Mattias and Marr, Stefan and Van Cutsem, Tom},\n  blog = {http://stefan-marr.de/2014/09/forkjoin-parallelism-in-the-wild/},\n  booktitle = {Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools},\n  doi = {10.1145/2647508.2647511},\n  isbn = {978-1-4503-2926-2},\n  keywords = {AntiPatterns EmpiricalStudy ForkJoin Java MeMyPublication OpenSource Patterns myown},\n  month = sep,\n  note = {(acceptance rate 39%)},\n  numpages = {12},\n  pages = {39--50},\n  pdf = {http://stefan-marr.de/downloads/pppj14-dewael-et-al-forkjoin-parallelism-in-the-wild.pdf},\n  series = {ManLang'14},\n  title = {Fork/Join Parallelism in the Wild: Documenting Patterns and Anti-Patterns in Java Programs using the Fork/Join Framework},\n  url = {http://stefan-marr.de/downloads/pppj14-dewael-et-al-forkjoin-parallelism-in-the-wild.pdf},\n  year = {2014},\n  month_numeric = {9}\n}\n"}, {"author"=>"Mattias De Wael, Stefan Marr, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"De Wael"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"Finding the right algorithm–data structure combination is easy, but finding the right data structure for a set of algorithms is much less trivial. Moreover, using the same data representation throughout the whole program might be sub-optimal. Depending on several factors, often only known at runtime, some programs benefit from changing the data representation during execution. In this position paper we introduce the idea of Just-In-Time data structures, a combination of a data interface and a set of concrete data representations with different performance characteristics. These Just-In- Time data structures can dynamically swap their internal data representation when the cost of swapping is payed back many times in the remainder of the computation. To make Just-In-Time data structures work, research is needed at three fronts: 1. We need to better understand the synergy between different data representations and algorithms; 2. We need a structured approach to handle the transitions between data representations; 3. We need descriptive programming constructs to express which representation fits a program fragment best. Combined, this research will result in a structured programming approach where separating data interface from data representation, not only improves understandability and maintainability, but also improves performance through automated transitions of data representation.", "title"=>"Data Interface + Algorithms = Efficient Programs: Separating Logic from Representation to Improve Performance", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2014", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 9th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems", "interhash"=>"84cfdcd7e08274f05427bc73fb4f3691", "publisher"=>"", "series"=>"ICOOOLPS", "series_venue"=>"ICOOOLPS", "school"=>"", "doi"=>"10.1145/2633301.2633303", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>"2:1&ndash;2:4", "publication_date"=>"jul 2014", "bibtex"=>"@inproceedings{dewael2014interface,\n  abstract = {Finding the right algorithm–data structure combination is easy, but finding the right data structure for a set of algorithms is much less trivial. Moreover, using the same data representation throughout the whole program might be sub-optimal. Depending on several factors, often only known at runtime, some programs benefit from changing the data representation during execution. In this position paper we introduce the idea of Just-In-Time data structures, a combination of a data interface and a set of concrete data representations with different performance characteristics. These Just-In- Time data structures can dynamically swap their internal data representation when the cost of swapping is payed back many times in the remainder of the computation. To make Just-In-Time data structures work, research is needed at three fronts: 1. We need to better understand the synergy between different data representations and algorithms; 2. We need a structured approach to handle the transitions between data representations; 3. We need descriptive programming constructs to express which representation fits a program fragment best. Combined, this research will result in a structured programming approach where separating data interface from data representation, not only improves understandability and maintainability, but also improves performance through automated transitions of data representation.},\n  articleno = {2},\n  author = {De Wael, Mattias and Marr, Stefan and De Meuter, Wolfgang},\n  booktitle = {Proceedings of the 9th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems},\n  doi = {10.1145/2633301.2633303},\n  isbn = {978-1-4503-2914-9},\n  keywords = {DataStructures JIT MeMyPublication myown},\n  location = {Uppsala, Sweden},\n  month = jul,\n  numpages = {4},\n  pages = {2:1--2:4},\n  series = {ICOOOLPS},\n  title = {Data Interface + Algorithms = Efficient Programs: Separating Logic from Representation to Improve Performance},\n  year = {2014},\n  month_numeric = {7}\n}\n"}, {"author"=>"Joeri De Koster, Stefan Marr, Theo D'Hondt, Tom Van Cutsem", "author_abbr_firstname"=>[{"first"=>"J.", "last"=>"De Koster"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"D'Hondt"}, {"first"=>"T.", "last"=>"Van Cutsem"}], "abstract"=>"The actor model is a concurrency model that avoids issues such as deadlocks and data races by construction, and thus facilitates concurrent programming. While it has mainly been used for expressing distributed computations, it is equally useful for modeling concurrent computations in a single shared memory machine. In component based software, the actor model lends itself to divide the components naturally over different actors and use message-passing concurrency for the interaction between these components. The tradeoff is that the actor model sacrifices expressiveness and efficiency with respect to parallel access to shared state.\r\n\r\nThis paper gives an overview of the disadvantages of the actor model when trying to express shared state and then formulates an extension of the actor model to solve these issues. Our solution proposes domains and synchronization views to solve the issues without compromising on the semantic properties of the actor model. Thus, the resulting concurrency model maintains deadlock-freedom and avoids low-level data races.", "title"=>"Domains: safe sharing among actors", "bibtype"=>"article", "type"=>"", "journal"=>"Science of Computer Programming", "year"=>"2015", "blog"=>"http://stefan-marr.de/2014/03/domains-safe-sharing-among-actors/", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"50ad0d471e74b756b23455837579b53d", "publisher"=>"", "series"=>"SCP", "series_venue"=>"SCP", "school"=>"", "doi"=>"10.1016/j.scico.2014.02.008", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/scp14-de-koster-et-al-domains-safe-sharing-among-actors.pdf", "pages"=>"140&ndash;158", "publication_date"=>"feb 2015", "bibtex"=>"@article{DeKoster2014,\n  abstract = {The actor model is a concurrency model that avoids issues such as deadlocks and data races by construction, and thus facilitates concurrent programming. While it has mainly been used for expressing distributed computations, it is equally useful for modeling concurrent computations in a single shared memory machine. In component based software, the actor model lends itself to divide the components naturally over different actors and use message-passing concurrency for the interaction between these components. The tradeoff is that the actor model sacrifices expressiveness and efficiency with respect to parallel access to shared state.\r\n  \r\n  This paper gives an overview of the disadvantages of the actor model when trying to express shared state and then formulates an extension of the actor model to solve these issues. Our solution proposes domains and synchronization views to solve the issues without compromising on the semantic properties of the actor model. Thus, the resulting concurrency model maintains deadlock-freedom and avoids low-level data races.},\n  author = {De Koster, Joeri and Marr, Stefan and D'Hondt, Theo and Van Cutsem, Tom},\n  blog = {http://stefan-marr.de/2014/03/domains-safe-sharing-among-actors/},\n  doi = {10.1016/j.scico.2014.02.008},\n  impactfactor2014 = {0.715},\n  impactfactor5year2014 = {0.837},\n  issn = {0167-6423},\n  journal = {Science of Computer Programming },\n  keywords = {Actors Domains MeMyPublication Synchronization Views myown},\n  month = feb,\n  pages = {140--158},\n  pdf = {http://stefan-marr.de/downloads/scp14-de-koster-et-al-domains-safe-sharing-among-actors.pdf},\n  series = {SCP},\n  title = {Domains: safe sharing among actors },\n  volume = {98, Part 2},\n  year = {2015},\n  month_numeric = {2}\n}\n"}, {"author"=>"Janwillem Swalens, Stefan Marr, Joeri De Koster, Tom Van Cutsem", "author_abbr_firstname"=>[{"first"=>"J.", "last"=>"Swalens"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"J.", "last"=>"De Koster"}, {"first"=>"T.", "last"=>"Van Cutsem"}], "abstract"=>"In the past decades, many different programming models for managing concurrency in applications have been proposed, such as the actor model, Communicating Sequential Processes, and Software Transactional Memory. The ubiquity of multi-core processors has made harnessing concurrency even more important.\r\nWe observe that modern languages, such as Scala, Clojure, or F\\#, provide not one, but \\emph{multiple} concurrency models that help developers manage concurrency.\r\nLarge end-user applications are rarely built using just a single concurrency model. Programmers need to manage a responsive UI, deal with file or network I/O, asynchronous workflows, and shared resources.\r\nDifferent concurrency models facilitate different requirements.\r\nThis raises the issue of how these concurrency models interact, and whether they are \\emph{composable}.\r\nAfter all, combining different concurrency models may lead to subtle bugs or inconsistencies.\r\n\r\nIn this paper, we perform an in-depth study of the concurrency abstractions provided by the Clojure language.\r\nWe study all pairwise combinations of the abstractions, noting which ones compose without issues, and which do not.\r\nWe make an attempt to abstract from the specifics of Clojure, identifying the general properties of concurrency models that facilitate or hinder composition.", "title"=>"Towards Composable Concurrency Abstractions", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"EPTCS", "year"=>"2014", "blog"=>"http://stefan-marr.de/2014/02/towards-composable-concurrency-abstractions/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the Workshop on Programming Language Approaches to Concurrency and communication-cEntric Software (PLACES)", "interhash"=>"2f7580427b696dba54a55639ea954133", "publisher"=>"", "series"=>"PLACES '14", "series_venue"=>"PLACES", "school"=>"", "doi"=>"10.4204/EPTCS.155.8", "howpublished"=>"", "number"=>"", "pdf"=>"http://arxiv.org/pdf/1406.3485", "pages"=>"54&ndash;60", "publication_date"=>"apr 2014", "bibtex"=>"@inproceedings{swalens2014towards,\n  abstract = {In the past decades, many different programming models for managing concurrency in applications have been proposed, such as the actor model, Communicating Sequential Processes, and Software Transactional Memory. The ubiquity of multi-core processors has made harnessing concurrency even more important.\r\n  We observe that modern languages, such as Scala, Clojure, or F\\#, provide not one, but \\emph{multiple} concurrency models that help developers manage concurrency.\r\n  Large end-user applications are rarely built using just a single concurrency model. Programmers need to manage a responsive UI, deal with file or network I/O, asynchronous workflows, and shared resources.\r\n  Different concurrency models facilitate different requirements.\r\n  This raises the issue of how these concurrency models interact, and whether they are \\emph{composable}.\r\n  After all, combining different concurrency models may lead to subtle bugs or inconsistencies.\r\n  \r\n  In this paper, we perform an in-depth study of the concurrency abstractions provided by the Clojure language.\r\n  We study all pairwise combinations of the abstractions, noting which ones compose without issues, and which do not.\r\n  We make an attempt to abstract from the specifics of Clojure, identifying the general properties of concurrency models that facilitate or hinder composition.},\n  author = {Swalens, Janwillem and Marr, Stefan and De Koster, Joeri and Van Cutsem, Tom},\n  blog = {http://stefan-marr.de/2014/02/towards-composable-concurrency-abstractions/},\n  booktitle = {Proceedings of the Workshop on Programming Language Approaches to Concurrency and communication-cEntric Software (PLACES)},\n  doi = {10.4204/EPTCS.155.8},\n  journal = {EPTCS},\n  keywords = {Actors Atoms CSP Clojure Concurrency MeMyPublication Programming STM Transactions VM myown},\n  month = apr,\n  pages = {54--60},\n  pdf = {http://arxiv.org/pdf/1406.3485},\n  series = {PLACES '14},\n  title = {Towards Composable Concurrency Abstractions},\n  url = {http://arxiv.org/abs/1406.3485},\n  volume = {155},\n  year = {2014},\n  month_numeric = {4}\n}\n"}, {"author"=>"Stefan Marr, Thierry Renaux, Lode Hoste, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"Renaux"}, {"first"=>"L.", "last"=>"Hoste"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"Using imperative programming to process event streams, such as\r\n    those generated by multi-touch devices and 3D cameras, has significant\r\n    engineering drawbacks. Declarative approaches solve common problems but\r\n    so far, they have not been able to scale on multicore systems while providing\r\n    guaranteed response times.\r\n\r\nWe propose PARTE, a parallel scalable complex event processing engine\r\n    that allows for a declarative definition of event patterns and provides soft\r\n    real-time guarantees for their recognition. The proposed approach extends\r\n    the classical\r\n    Rete algorithm and maps event matching onto a graph of actor nodes.\r\n    Using a tiered event matching model, PARTE provides upper bounds on the\r\n    detection latency by relying on a combination of non-blocking\r\n    message passing between Rete nodes and safe memory management techniques.\r\n    \r\nThe performance evaluation shows the scalability of our approach on up to\r\n    64 cores. Moreover, it indicates that PARTE's design choices lead to\r\n    more predictable performance compared to a PARTE variant without soft\r\n    real-time guarantees. Finally, the evaluation indicates further that gesture\r\n    recognition can benefit from the exposed parallelism with superlinear\r\n    speedups.", "title"=>"Parallel Gesture Recognition with Soft Real-Time Guarantees", "bibtype"=>"article", "type"=>"", "journal"=>"Science of Computer Programming", "year"=>"2015", "blog"=>"http://stefan-marr.de/2014/02/parallel-gesture-recognition-with-soft-real-time-guarantees-2/", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"e427ac910ad10a3b4f055fe6eee0822e", "publisher"=>"", "series"=>"SCP", "series_venue"=>"SCP", "school"=>"", "doi"=>"10.1016/j.scico.2014.02.012", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/scp14-marr-et-al-parallel-gesture-recognition-with-soft-real-time-guarantees.pdf", "pages"=>"159&ndash;183", "publication_date"=>"1 feb 2015", "bibtex"=>"@article{marr2014parallel,\n  abstract = {Using imperative programming to process event streams, such as\r\n      those generated by multi-touch devices and 3D cameras, has significant\r\n      engineering drawbacks. Declarative approaches solve common problems but\r\n      so far, they have not been able to scale on multicore systems while providing\r\n      guaranteed response times.\r\n  \r\n  We propose PARTE, a parallel scalable complex event processing engine\r\n      that allows for a declarative definition of event patterns and provides soft\r\n      real-time guarantees for their recognition. The proposed approach extends\r\n      the classical\r\n      Rete algorithm and maps event matching onto a graph of actor nodes.\r\n      Using a tiered event matching model, PARTE provides upper bounds on the\r\n      detection latency by relying on a combination of non-blocking\r\n      message passing between Rete nodes and safe memory management techniques.\r\n      \r\n  The performance evaluation shows the scalability of our approach on up to\r\n      64 cores. Moreover, it indicates that PARTE's design choices lead to\r\n      more predictable performance compared to a PARTE variant without soft\r\n      real-time guarantees. Finally, the evaluation indicates further that gesture\r\n      recognition can benefit from the exposed parallelism with superlinear\r\n      speedups.},\n  author = {Marr, Stefan and Renaux, Thierry and Hoste, Lode and De Meuter, Wolfgang},\n  blog = {http://stefan-marr.de/2014/02/parallel-gesture-recognition-with-soft-real-time-guarantees-2/},\n  day = {1},\n  doi = {10.1016/j.scico.2014.02.012},\n  impactfactor2014 = {0.715},\n  impactfactor5year2014 = {0.837},\n  issn = {0167-6423},\n  journal = {Science of Computer Programming},\n  keywords = {Clips MeMyPublication PARTE RealTime Rete RulesEngine VM myown},\n  month = feb,\n  pages = {159--183},\n  pdf = {http://stefan-marr.de/downloads/scp14-marr-et-al-parallel-gesture-recognition-with-soft-real-time-guarantees.pdf},\n  series = {SCP},\n  title = {Parallel Gesture Recognition with Soft Real-Time Guarantees},\n  url = {http://stefan-marr.de/downloads/scp14-marr-et-al-parallel-gesture-recognition-with-soft-real-time-guarantees.pdf},\n  volume = {98, Part 2},\n  year = {2015},\n  month_numeric = {2}\n}\n"}, {"author"=>"Joeri De Koster, Stefan Marr, Theo D'Hondt, Tom Van Cutsem", "author_abbr_firstname"=>[{"first"=>"J.", "last"=>"De Koster"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"D'Hondt"}, {"first"=>"T.", "last"=>"Van Cutsem"}], "abstract"=>"In the past, the Actor Model has mainly been explored in a distributed context. However, more and more application developers are also starting to use it to program shared-memory multicore machines because of the safety guarantees it provides. It avoids issues such as deadlocks and race conditions by construction, and thus facilitates concurrent programming. The tradeoff is that the Actor Model sacrifices expressiveness with respect to accessing shared state because actors are fully isolated from each other (a.k.a. \"shared-nothing parallelism\"). There is a need for more high level synchronization mechanisms that integrate with the actor model without sacrificing the safety and liveness guarantees it provides. This paper introduces a variation on the communicating event-loops actor model called the Tank model. A tank is an actor that can expose part of its state as a shared read-only resource. The model ensures that any other actor will always observe a consistent version of that state, even in the face of concurrent updates of the actor that owns that state.", "title"=>"Tanks: Multiple reader, single writer actors", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2013", "blog"=>"http://stefan-marr.de/2013/10/tanks-multiple-reader-single-writer-actors/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of AGERE! 2013, 3rd International Workshop on Programming based on Actors, Agents, and Decentralized Control", "interhash"=>"c1db1b07f46be7b49019a847b90ae145", "publisher"=>"", "series"=>"AGERE!'13", "series_venue"=>"AGERE!", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/agere13-de-koster-et-al-tanks-multiple-reader-single-writer-actors.pdf", "pages"=>"61&ndash;68", "publication_date"=>"27 oct 2013", "bibtex"=>"@inproceedings{dekoster2013tanks,\n  abstract = {In the past, the Actor Model has mainly been explored in a distributed context. However, more and more application developers are also starting to use it to program shared-memory multicore machines because of the safety guarantees it provides. It avoids issues such as deadlocks and race conditions by construction, and thus facilitates concurrent programming. The tradeoff is that the Actor Model sacrifices expressiveness with respect to accessing shared state because actors are fully isolated from each other (a.k.a. \"shared-nothing parallelism\"). There is a need for more high level synchronization mechanisms that integrate with the actor model without sacrificing the safety and liveness guarantees it provides. This paper introduces a variation on the communicating event-loops actor model called the Tank model. A tank is an actor that can expose part of its state as a shared read-only resource. The model ensures that any other actor will always observe a consistent version of that state, even in the face of concurrent updates of the actor that owns that state.},\n  author = {De Koster, Joeri and Marr, Stefan and D'Hondt, Theo and Van Cutsem, Tom},\n  blog = {http://stefan-marr.de/2013/10/tanks-multiple-reader-single-writer-actors/},\n  booktitle = {Proceedings of AGERE! 2013, 3rd International Workshop on Programming based on Actors, Agents, and Decentralized Control},\n  day = {27},\n  isbn = {978-1-4503-2602-5},\n  keywords = {Actors Concurrency ConcurrentReads Consistency Encapsulation EventLoops Isolation MeMyPublication myown},\n  location = {Indianapolis, Indiana, USA},\n  month = oct,\n  numpages = {8},\n  pages = {61--68},\n  pdf = {http://stefan-marr.de/downloads/agere13-de-koster-et-al-tanks-multiple-reader-single-writer-actors.pdf},\n  series = {AGERE!'13},\n  title = {Tanks: Multiple reader, single writer actors},\n  url = {http://soft.vub.ac.be/~smarr/downloads/agere13-de-koster-et-al-tanks-multiple-reader-single-writer-actors.pdf},\n  year = {2013},\n  month_numeric = {10}\n}\n"}, {"author"=>"Janwillem Swalens, Thierry Renaux, Lode Hoste, Stefan Marr, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"J.", "last"=>"Swalens"}, {"first"=>"T.", "last"=>"Renaux"}, {"first"=>"L.", "last"=>"Hoste"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"Traffic monitoring or crowd management systems produce large amounts of data in the form of events that need to be processed to detect relevant incidents.\r\n\r\nRule-based pattern recognition is a promising approach for these applications, however, increasing amounts of data as well as large and complex rule sets demand for more and more processing power and memory. In order to scale such applications, a rule-based pattern detection system needs to be distributable over multiple machines. Today's approaches are however focused on static distribution of rules or do not support reasoning over the full set of events.\r\n\r\nWe propose Cloud PARTE, a complex event detection system that implements the Rete algorithm on top of mobile actors. These actors can migrate between machines to respond to changes in the work load distribution. Cloud PARTE is an extension of PARTE and offers the first rule engine specifically tailored for continuous complex event detection that is able to benefit from elastic systems as provided by cloud computing platforms. It supports fully automatic load balancing and supports online rules with access to the entire event pool.", "title"=>"Cloud PARTE: Elastic Complex Event Processing based on Mobile Actors", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2013", "blog"=>"http://stefan-marr.de/2013/10/cloud-parte-elastic-complex-event-processing-based-on-mobile-actors/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of AGERE! 2013, 3rd International Workshop on Programming based on Actors, Agents, and Decentralized Control", "interhash"=>"7fc89cd94011a7d61fece752a317db98", "publisher"=>"ACM", "series"=>"AGERE! '13", "series_venue"=>"AGERE!", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://soft.vub.ac.be/~smarr/downloads/agere13-swalens-et-al-cloud-parte-elastic-complex-event-processing-based-on-mobile-actors.pdf", "pages"=>"3&ndash;12", "publication_date"=>"oct 2013", "bibtex"=>"@inproceedings{Swalens2013cloud,\n  abstract = {Traffic monitoring or crowd management systems produce large amounts of data in the form of events that need to be processed to detect relevant incidents.\r\n  \r\n  Rule-based pattern recognition is a promising approach for these applications, however, increasing amounts of data as well as large and complex rule sets demand for more and more processing power and memory. In order to scale such applications, a rule-based pattern detection system needs to be distributable over multiple machines. Today's approaches are however focused on static distribution of rules or do not support reasoning over the full set of events.\r\n  \r\n  We propose Cloud PARTE, a complex event detection system that implements the Rete algorithm on top of mobile actors. These actors can migrate between machines to respond to changes in the work load distribution. Cloud PARTE is an extension of PARTE and offers the first rule engine specifically tailored for continuous complex event detection that is able to benefit from elastic systems as provided by cloud computing platforms. It supports fully automatic load balancing and supports online rules with access to the entire event pool.},\n  author = {Swalens, Janwillem and Renaux, Thierry and Hoste, Lode and Marr, Stefan and De Meuter, Wolfgang},\n  blog = {http://stefan-marr.de/2013/10/cloud-parte-elastic-complex-event-processing-based-on-mobile-actors/},\n  booktitle = {Proceedings of AGERE! 2013, 3rd International Workshop on Programming based on Actors, Agents, and Decentralized Control},\n  keywords = {BigData Cloud Distribution Elasicity Inference LoadBalancing MeMyPublication Rete TrafficMonitoring myown},\n  month = oct,\n  pages = {3--12},\n  pdf = {http://soft.vub.ac.be/~smarr/downloads/agere13-swalens-et-al-cloud-parte-elastic-complex-event-processing-based-on-mobile-actors.pdf},\n  publisher = {ACM},\n  series = {AGERE! '13},\n  title = {Cloud PARTE: Elastic Complex Event Processing based on Mobile Actors},\n  url = {http://soft.vub.ac.be/~smarr/downloads/agere13-swalens-et-al-cloud-parte-elastic-complex-event-processing-based-on-mobile-actors.pdf},\n  year = {2013},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}], "abstract"=>"During the past decade, software developers widely adopted JVM and CLI as multi-language virtual machines (VMs). At the same time, the multicore revolution burdened developers with increasing complexity. Language implementers devised a wide range of concurrent and parallel programming concepts to address this complexity but struggle to build these concepts on top of common multi-language VMs. Missing support in these VMs leads to tradeoffs between implementation simplicity, correctly implemented language semantics, and performance guarantees.\r\n\r\nDeparting from the traditional distinction between concurrency and parallelism, this dissertation finds that parallel programming concepts benefit from performance-related VM support, while concurrent programming concepts benefit from VM support that guarantees correct semantics in the presence of reflection, mutable state, and interaction with other languages and libraries.\r\n\r\nFocusing on these concurrent programming concepts, this dissertation finds that a VM needs to provide mechanisms for managed state, managed execution, ownership, and controlled enforcement. Based on these requirements, this dissertation proposes an ownership-based metaobject protocol (OMOP) to build novel multi-language VMs with proper concurrent programming support.\r\n\r\nThis dissertation demonstrates the OMOP's benefits by building concurrent programming concepts such as agents, software transactional memory, actors, active objects, and communicating sequential processes on top of the OMOP. The performance evaluation shows that OMOP-based implementations of concurrent programming concepts can reach performance on par with that of their conventionally implemented counterparts if the OMOP is supported by the VM.\r\n\r\nTo conclude, the OMOP proposed in this dissertation provides a unifying and minimal substrate to support concurrent programming on top of multi-language VMs. The OMOP enables language implementers to correctly implement language semantics, while simultaneously enabling VMs to provide efficient implementations.", "title"=>"Supporting Concurrency Abstractions in High-level Language Virtual Machines", "bibtype"=>"phdthesis", "type"=>"", "journal"=>"", "year"=>"2013", "blog"=>"http://stefan-marr.de/2013/01/supporting-concurrency-abstractions-in-high-level-language-virtual-machines/", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"2a637e553d371aa60c7da444baefb1d1", "publisher"=>"VUBPress", "series"=>"SOFT PhD", "series_venue"=>"SOFT PhD", "school"=>"Software Languages Lab, Vrije Universiteit Brussel", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/marr-phd-2013-supporting-concurrency-abstractions-in-high-level-language-virtual-machines.pdf", "pages"=>nil, "publication_date"=>"jan 2013", "bibtex"=>"@phdthesis{marr2013phd,\n  abstract = {During the past decade, software developers widely adopted JVM and CLI as multi-language virtual machines (VMs). At the same time, the multicore revolution burdened developers with increasing complexity. Language implementers devised a wide range of concurrent and parallel programming concepts to address this complexity but struggle to build these concepts on top of common multi-language VMs. Missing support in these VMs leads to tradeoffs between implementation simplicity, correctly implemented language semantics, and performance guarantees.\r\n  \r\n  Departing from the traditional distinction between concurrency and parallelism, this dissertation finds that parallel programming concepts benefit from performance-related VM support, while concurrent programming concepts benefit from VM support that guarantees correct semantics in the presence of reflection, mutable state, and interaction with other languages and libraries.\r\n  \r\n  Focusing on these concurrent programming concepts, this dissertation finds that a VM needs to provide mechanisms for managed state, managed execution, ownership, and controlled enforcement. Based on these requirements, this dissertation proposes an ownership-based metaobject protocol (OMOP) to build novel multi-language VMs with proper concurrent programming support.\r\n  \r\n  This dissertation demonstrates the OMOP's benefits by building concurrent programming concepts such as agents, software transactional memory, actors, active objects, and communicating sequential processes on top of the OMOP. The performance evaluation shows that OMOP-based implementations of concurrent programming concepts can reach performance on par with that of their conventionally implemented counterparts if the OMOP is supported by the VM.\r\n  \r\n  To conclude, the OMOP proposed in this dissertation provides a unifying and minimal substrate to support concurrent programming on top of multi-language VMs. The OMOP enables language implementers to correctly implement language semantics, while simultaneously enabling VMs to provide efficient implementations.},\n  address = {Pleinlaan 2, B-1050 Brussels, Belgium},\n  author = {Marr, Stefan},\n  blog = {http://stefan-marr.de/2013/01/supporting-concurrency-abstractions-in-high-level-language-virtual-machines/},\n  isbn = {978-90-5718-256-3},\n  keywords = {Concurrency Domains MOP MeMyPublication MetaObjectProtocol OMOP Ownership VMs VirtualMachine myown},\n  month = jan,\n  pdf = {http://www.stefan-marr.de/downloads/marr-phd-2013-supporting-concurrency-abstractions-in-high-level-language-virtual-machines.pdf},\n  publisher = {VUBPress},\n  school = {Software Languages Lab, Vrije Universiteit Brussel},\n  series = {SOFT PhD},\n  title = {Supporting Concurrency Abstractions in High-level Language Virtual Machines},\n  url = {http://www.stefan-marr.de/2013/01/supporting-concurrency-abstractions-in-high-level-language-virtual-machines/},\n  year = {2013},\n  month_numeric = {1}\n}\n"}, {"author"=>"Thierry Renaux, Lode Hoste, Stefan Marr, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"T.", "last"=>"Renaux"}, {"first"=>"L.", "last"=>"Hoste"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"Applying imperative programming techniques to process event streams, like those generated by multi-touch devices and 3D cameras, has significant engineering drawbacks. Declarative approaches solve these problems but have not been able to scale on multicore systems while providing guaranteed response times.</p> <p>We propose PARTE, a parallel scalable complex event processing engine which allows a declarative definition of event patterns and provides soft real-time guarantees for their recognition. It extends the state-saving Rete algorithm and maps the event matching onto a graph of actor nodes. Using a tiered event matching model, PARTEprovides upper bounds on the detection latency. Based on the domain-specific constraints, PARTE's design relies on a combination of 1) lock-free data structures; 2) safe memory management techniques; and 3) message passing between Rete nodes. In our benchmarks, we measured scalability up to 8 cores, outperforming highly optimized sequential implementations.", "title"=>"Parallel Gesture Recognition with Soft Real-Time Guarantees", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2012", "blog"=>"http://stefan-marr.de/2013/01/parallel-gesture-recognition-with-soft-real-time-guarantees/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 2nd edition on Programming Systems, Languages and Applications based on Actors, Agents, and Decentralized Control Abstractions", "interhash"=>"97c79f5ee7d0e355dcb0ebb862fd5bd5", "publisher"=>"", "series"=>"AGERE!'12", "series_venue"=>"AGERE!", "school"=>"", "doi"=>"10.1145/2414639.2414646", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/agere12-parallel-gesture-recognition-with-soft-real-time-guarantees.pdf", "pages"=>"35&ndash;46", "publication_date"=>"oct 2012", "bibtex"=>"@inproceedings{renaux2012parte,\n  abstract = {Applying imperative programming techniques to process event streams, like those generated by multi-touch devices and 3D cameras, has significant engineering drawbacks. Declarative approaches solve these problems but have not been able to scale on multicore systems while providing guaranteed response times.</p> <p>We propose PARTE, a parallel scalable complex event processing engine which allows a declarative definition of event patterns and provides soft real-time guarantees for their recognition. It extends the state-saving Rete algorithm and maps the event matching onto a graph of actor nodes. Using a tiered event matching model, PARTEprovides upper bounds on the detection latency. Based on the domain-specific constraints, PARTE's design relies on a combination of 1) lock-free data structures; 2) safe memory management techniques; and 3) message passing between Rete nodes. In our benchmarks, we measured scalability up to 8 cores, outperforming highly optimized sequential implementations.},\n  acmid = {2414646},\n  author = {Renaux, Thierry and Hoste, Lode and Marr, Stefan and De Meuter, Wolfgang},\n  blog = {http://stefan-marr.de/2013/01/parallel-gesture-recognition-with-soft-real-time-guarantees/},\n  booktitle = {Proceedings of the 2nd edition on Programming Systems, Languages and Applications based on Actors, Agents, and Decentralized Control Abstractions},\n  doi = {10.1145/2414639.2414646},\n  isbn = {978-1-4503-1630-9},\n  keywords = {MeMyPublication actors dataflow guarantees myown realtime rete},\n  location = {Tucson, Arizona, USA},\n  month = oct,\n  numpages = {12},\n  pages = {35--46},\n  pdf = {http://www.stefan-marr.de/downloads/agere12-parallel-gesture-recognition-with-soft-real-time-guarantees.pdf},\n  series = {AGERE!'12},\n  title = {Parallel Gesture Recognition with Soft Real-Time Guarantees},\n  url = {http://www.stefan-marr.de/2013/01/parallel-gesture-recognition-with-soft-real-time-guarantees/},\n  year = {2012},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr, David Ungar, Theo D'Hondt", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"D.", "last"=>"Ungar"}, {"first"=>"T.", "last"=>"D'Hondt"}], "title"=>"Evolving A Virtual Machine to Execute Applications Fully in Parallel: Approaching the Multi- and Manycore Challenge with a Simplified Design", "bibtype"=>"unpublished", "type"=>"", "journal"=>"", "year"=>"2011", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"959d45151e16ba1939e8e5ef03dca641", "publisher"=>"", "series"=>"unpublished", "series_venue"=>"unpublished", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"", "pages"=>nil, "publication_date"=>"may 2011", "bibtex"=>"@unpublished{marr2011evolving,\n  author = {Marr, Stefan and Ungar, David and D'Hondt, Theo},\n  keywords = {MeMyPublication Unpublished myown},\n  month = may,\n  note = {(unpublished)},\n  series = {unpublished},\n  title = {Evolving A Virtual Machine to Execute Applications Fully in Parallel: Approaching the Multi- and Manycore Challenge with a Simplified Design},\n  year = {2011},\n  month_numeric = {5}\n}\n"}, {"author"=>"Stefan Marr, Theo D'Hondt", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"D'Hondt"}], "abstract"=>"Supporting all known abstractions for concurrent\r\nand parallel programming in a virtual machines (VM) is a futile\r\nundertaking, but it is required to give programmers appropriate tools and\r\nperformance. Instead of supporting all abstractions directly,\r\nVMs need a unifying mechanism similar to \\texttt{INVOKEDYNAMIC} for JVMs.\r\n\r\nOur survey of parallel and concurrent programming concepts identifies\r\nconcurrency abstractions as the ones benefiting most from support in a VM.\r\nCurrently, their semantics is often weakened, reducing their engineering benefits.\r\nThey require a mechanism to define flexible language guarantees.\r\n\r\nBased on this survey, we define an ownership-based meta-object protocol\r\nas candidate for VM support. We demonstrate its expressiveness by\r\nimplementing actor semantics, software transactional memory, agents,\r\nCSP, and active objects.\r\nWhile the performance of our prototype confirms the need for VM support, it\r\nalso shows that the chosen mechanism is appropriate to express a\r\nwide range of concurrency abstractions in a unified way.", "title"=>"Identifying A Unifying Mechanism for the Implementation of Concurrency Abstractions on Multi-Language Virtual Machines", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2012", "blog"=>"http://stefan-marr.de/2012/03/identifying-a-unifying-mechanism-for-the-implementation-of-concurrency-abstractions-on-multi-language-virtual-machines/", "html"=>"", "appendix"=>"", "booktitle"=>"Objects, Models, Components, Patterns, 50th International Conference, TOOLS 2012", "interhash"=>"e95335bd7d37bc29f2bb45e9ad362572", "publisher"=>"Springer", "series"=>"TOOLS'12 (LNCS)", "series_venue"=>"TOOLS", "school"=>"", "doi"=>"10.1007/978-3-642-30561-0_13", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/tools12-smarr-dhondt-identifying-a-unifying-mechanism-for-the-implementation-of-concurrency-abstractions-on-multi-language-virtual-machines.pdf", "pages"=>"171&ndash;186", "publication_date"=>"may 2012", "bibtex"=>"@inproceedings{MOP_TOOLS,\n  abstract = {Supporting all known abstractions for concurrent\r\n  and parallel programming in a virtual machines (VM) is a futile\r\n  undertaking, but it is required to give programmers appropriate tools and\r\n  performance. Instead of supporting all abstractions directly,\r\n  VMs need a unifying mechanism similar to \\texttt{INVOKEDYNAMIC} for JVMs.\r\n  \r\n  Our survey of parallel and concurrent programming concepts identifies\r\n  concurrency abstractions as the ones benefiting most from support in a VM.\r\n  Currently, their semantics is often weakened, reducing their engineering benefits.\r\n  They require a mechanism to define flexible language guarantees.\r\n  \r\n  Based on this survey, we define an ownership-based meta-object protocol\r\n  as candidate for VM support. We demonstrate its expressiveness by\r\n  implementing actor semantics, software transactional memory, agents,\r\n  CSP, and active objects.\r\n  While the performance of our prototype confirms the need for VM support, it\r\n  also shows that the chosen mechanism is appropriate to express a\r\n  wide range of concurrency abstractions in a unified way.},\n  acceptancerate = {0.31},\n  address = {Berlin / Heidelberg},\n  author = {Marr, Stefan and D'Hondt, Theo},\n  blog = {http://stefan-marr.de/2012/03/identifying-a-unifying-mechanism-for-the-implementation-of-concurrency-abstractions-on-multi-language-virtual-machines/},\n  booktitle = {Objects, Models, Components, Patterns, 50th International Conference, TOOLS 2012},\n  doi = {10.1007/978-3-642-30561-0_13},\n  isbn = {978-3-642-30560-3},\n  keywords = {Abstraction Concurrency LanguageSupport MeMyPublication Parallelism VirtualMachine myown},\n  month = may,\n  note = {(acceptance rate 31%)},\n  pages = {171-186},\n  pdf = {http://www.stefan-marr.de/downloads/tools12-smarr-dhondt-identifying-a-unifying-mechanism-for-the-implementation-of-concurrency-abstractions-on-multi-language-virtual-machines.pdf},\n  publisher = {Springer},\n  series = {TOOLS'12 (LNCS)},\n  title = {Identifying A Unifying Mechanism for the Implementation of Concurrency Abstractions on Multi-Language Virtual Machines},\n  url = {http://www.stefan-marr.de/2012/03/identifying-a-unifying-mechanism-for-the-implementation-of-concurrency-abstractions-on-multi-language-virtual-machines/},\n  volume = {7304},\n  year = {2012},\n  month_numeric = {5}\n}\n"}, {"author"=>"Stefan Marr, Jens Nicolay, Tom Van Cutsem, Theo D'Hondt", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"J.", "last"=>"Nicolay"}, {"first"=>"T.", "last"=>"Van Cutsem"}, {"first"=>"T.", "last"=>"D'Hondt"}], "abstract"=>"In this paper, we review what we have learned from implementing languages for\r\nparallel and concurrent programming, and investigate the role of modularity.\r\nTo identify the approaches used to facilitate correctness and maintainability,\r\nwe ask the following questions: What guides modularization? Are informal\r\napproaches used to facilitate correctness? Are concurrency concerns\r\nmodularized? And, where is language support lacking most?\r\n\r\nOur subjects are AmbientTalk, SLIP, and the RoarVM. All three evolved over the\r\nyears, enabling us to look back at specific experiments to understand the\r\nimpact of concurrency on modularity.\r\n\r\nWe conclude from our review that concurrency concerns are one of the strongest\r\ndrivers for the definition of module boundaries. It helps when languages offer\r\nsophisticated modularization constructs. However, with respect to concurrency,\r\nother language features like single-assignment are of greater importance.\r\nFurthermore, tooling that enables remodularization taking concurrency\r\ninvariants into account would be of great value.", "title"=>"Modularity and Conventions for Maintainable Concurrent Language Implementations: A Review of Our Experiences and Practices", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2012", "blog"=>"http://stefan-marr.de/2012/01/modularity-and-conventions-for-maintainable-concurrent-language-implementations-a-review-of-our-experiences-and-practices/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 2nd Workshop on Modularity In Systems Software (MISS'2012)", "interhash"=>"f6aa985b183f15b014127ac282ce73d5", "publisher"=>"ACM", "series"=>"MISS'12", "series_venue"=>"MISS", "school"=>"", "doi"=>"10.1145/2162024.2162031", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/miss12-smarr-et-al-modularity-and-conventions-for-maintainable-concurrent-language-implementations.pdf", "pages"=>"21&ndash;26", "publication_date"=>"mar 2012", "bibtex"=>"@inproceedings{MISS2012,\n  abstract = {In this paper, we review what we have learned from implementing languages for\r\n  parallel and concurrent programming, and investigate the role of modularity.\r\n  To identify the approaches used to facilitate correctness and maintainability,\r\n  we ask the following questions: What guides modularization? Are informal\r\n  approaches used to facilitate correctness? Are concurrency concerns\r\n  modularized? And, where is language support lacking most?\r\n  \r\n  Our subjects are AmbientTalk, SLIP, and the RoarVM. All three evolved over the\r\n  years, enabling us to look back at specific experiments to understand the\r\n  impact of concurrency on modularity.\r\n  \r\n  We conclude from our review that concurrency concerns are one of the strongest\r\n  drivers for the definition of module boundaries. It helps when languages offer\r\n  sophisticated modularization constructs. However, with respect to concurrency,\r\n  other language features like single-assignment are of greater importance.\r\n  Furthermore, tooling that enables remodularization taking concurrency\r\n  invariants into account would be of great value.},\n  acmid = {2162031},\n  author = {Marr, Stefan and Nicolay, Jens and Van Cutsem, Tom and D'Hondt, Theo},\n  blog = {http://stefan-marr.de/2012/01/modularity-and-conventions-for-maintainable-concurrent-language-implementations-a-review-of-our-experiences-and-practices/},\n  booktitle = {Proceedings of the 2nd Workshop on Modularity In Systems Software (MISS'2012)},\n  doi = {10.1145/2162024.2162031},\n  isbn = {978-1-4503-1217-2},\n  keywords = {CaseStudy Concurrency ExperienceReport Interpreters MeMyPublication Modularity Parallelism VMs myown},\n  location = {Potsdam, Germany},\n  month = mar,\n  numpages = {6},\n  pages = {21--26},\n  pdf = {http://www.stefan-marr.de/downloads/miss12-smarr-et-al-modularity-and-conventions-for-maintainable-concurrent-language-implementations.pdf},\n  publisher = {ACM},\n  series = {MISS'12},\n  title = {Modularity and Conventions for Maintainable Concurrent Language Implementations: A Review of Our Experiences and Practices},\n  url = {http://www.stefan-marr.de/2012/01/modularity-and-conventions-for-maintainable-concurrent-language-implementations-a-review-of-our-experiences-and-practices/},\n  year = {2012},\n  month_numeric = {3}\n}\n"}, {"author"=>"Joeri De Koster, Stefan Marr, Theo D'Hondt", "author_abbr_firstname"=>[{"first"=>"J.", "last"=>"De Koster"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"D'Hondt"}], "abstract"=>"The actor model has already proven itself as an interesting concurrency model\r\nthat avoids issues such as deadlocks and race conditions by construction, and\r\nthus facilitates concurrent programming. The tradeoff is that it sacrifices\r\nexpressiveness and efficiency especially with respect to data parallelism.\r\nHowever, many standard solutions to computationally expensive problems employ\r\ndata parallel algorithms for better performance on parallel systems.\r\n\r\nWe identified three problems that inhibit the use of data-parallel algorithms\r\nwithin the actor model. Firstly, one of the main properties of the actor\r\nmodel, the fact that no data is shared, is one of the most severe performance\r\nbottlenecks. Especially the fact that shared state can not be read truly in\r\nparallel. Secondly, the actor model on its own does not provide a mechanism to\r\nspecify extra synchronization conditions on batches of messages which leads to\r\nevent-level data-races. And lastly, programmers are forced to write code in a\r\ncontinuation-passing style (CPS) to handle typical request-response\r\nsituations. However, CPS breaks the sequential flow of the code and is often\r\nhard to understand, which increases complexity and lowers maintainability.\r\n\r\nWe proposes \\emph{synchronization views} to solve these three issues\r\nwithout compromising the semantic properties of the actor model. Thus, the\r\nresulting concurrency model maintains deadlock-freedom, avoids low-level race\r\nconditions, and keeps the semantics of macro-step execution.", "title"=>"Synchronization Views for Event-loop Actors", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2012", "blog"=>"http://stefan-marr.de/2011/12/synchronization-views-for-event-loop-actors/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 17th ACM SIGPLAN symposium on Principles and Practice of Parallel Programming", "interhash"=>"e727f9c6a21c1e3b6370fbf9db8b7e35", "publisher"=>"ACM", "series"=>"PPoPP Poster'12", "series_venue"=>"PPoPP Poster", "school"=>"", "doi"=>"10.1145/2145816.2145873", "howpublished"=>"", "number"=>"", "pdf"=>"http://soft.vub.ac.be/~smarr/downloads/ppopp12-dekoster-synchronization-views-for-event-loop-actors.pdf", "pages"=>"317&ndash;318", "publication_date"=>"feb 2012", "bibtex"=>"@inproceedings{SyncViewsPoster,\n  abstract = {The actor model has already proven itself as an interesting concurrency model\r\n  that avoids issues such as deadlocks and race conditions by construction, and\r\n  thus facilitates concurrent programming. The tradeoff is that it sacrifices\r\n  expressiveness and efficiency especially with respect to data parallelism.\r\n  However, many standard solutions to computationally expensive problems employ\r\n  data parallel algorithms for better performance on parallel systems.\r\n  \r\n  We identified three problems that inhibit the use of data-parallel algorithms\r\n  within the actor model. Firstly, one of the main properties of the actor\r\n  model, the fact that no data is shared, is one of the most severe performance\r\n  bottlenecks. Especially the fact that shared state can not be read truly in\r\n  parallel. Secondly, the actor model on its own does not provide a mechanism to\r\n  specify extra synchronization conditions on batches of messages which leads to\r\n  event-level data-races. And lastly, programmers are forced to write code in a\r\n  continuation-passing style (CPS) to handle typical request-response\r\n  situations. However, CPS breaks the sequential flow of the code and is often\r\n  hard to understand, which increases complexity and lowers maintainability.\r\n  \r\n  We proposes \\emph{synchronization views} to solve these three issues\r\n  without compromising the semantic properties of the actor model. Thus, the\r\n  resulting concurrency model maintains deadlock-freedom, avoids low-level race\r\n  conditions, and keeps the semantics of macro-step execution.},\n  author = {De Koster, Joeri and Marr, Stefan and D'Hondt, Theo},\n  blog = {http://stefan-marr.de/2011/12/synchronization-views-for-event-loop-actors/},\n  booktitle = {Proceedings of the 17th ACM SIGPLAN symposium on Principles and Practice of Parallel Programming},\n  doi = {10.1145/2145816.2145873},\n  keywords = {ActPigoo Actors Concurrency MeMyPublication Parallelism ReaderWriter Synchronization Views myown},\n  month = feb,\n  note = {(Poster)},\n  pages = {317--318},\n  pdf = {http://soft.vub.ac.be/~smarr/downloads/ppopp12-dekoster-synchronization-views-for-event-loop-actors.pdf},\n  publisher = {ACM},\n  series = {PPoPP Poster'12},\n  title = {Synchronization Views for Event-loop Actors},\n  url = {http://www.stefan-marr.de/2011/12/synchronization-views-for-event-loop-actors/},\n  year = {2012},\n  month_numeric = {2}\n}\n"}, {"author"=>"Michael Haupt, Stefan Marr, Robert Hirschfeld", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"Haupt"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"R.", "last"=>"Hirschfeld"}], "abstract"=>"CSOM/PL is a software product line (SPL) derived from applying multi-dimensional separation of concerns (MDSOC) techniques to the domain of high-level language virtual machine (VM) implementations. For CSOM/PL, we modularised CSOM, a Smalltalk VM implemented in C, using VMADL (virtual machine architecture description language). Several features of the original CSOM were encapsulated in VMADL modules and composed in various combinations. In an evaluation of our approach, we show that applying MDSOC and SPL principles to a domain as complex as that of VMs is not only feasible but beneficial, as it improves understandability, maintainability, and configurability of VM implementations without harming performance.\r\n", "title"=>"CSOM/PL: A Virtual Machine Product Line", "bibtype"=>"article", "type"=>"", "journal"=>"Journal of Object Technology", "year"=>"2011", "blog"=>"http://stefan-marr.de/2011/12/csompl-a-virtual-machine-product-line/", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"b739ed923a0c65e0a687575c5ae724b3", "publisher"=>"", "series"=>"JoT", "series_venue"=>"JoT", "school"=>"", "doi"=>"10.5381/jot.2011.10.1.a12", "howpublished"=>"", "number"=>"12", "pdf"=>"http://www.stefan-marr.de/downloads/jot11-mhaupt-csompl-a-virtual-machine-product-line.pdf", "pages"=>"1&ndash;30", "publication_date"=>"dec 2011", "bibtex"=>"@article{CSOMPL_JOT,\n  abstract = {CSOM/PL is a software product line (SPL) derived from applying multi-dimensional separation of concerns (MDSOC) techniques to the domain of high-level language virtual machine (VM) implementations. For CSOM/PL, we modularised CSOM, a Smalltalk VM implemented in C, using VMADL (virtual machine architecture description language). Several features of the original CSOM were encapsulated in VMADL modules and composed in various combinations. In an evaluation of our approach, we show that applying MDSOC and SPL principles to a domain as complex as that of VMs is not only feasible but beneficial, as it improves understandability, maintainability, and configurability of VM implementations without harming performance.\r\n  },\n  author = {Haupt, Michael and Marr, Stefan and Hirschfeld, Robert},\n  blog = {http://stefan-marr.de/2011/12/csompl-a-virtual-machine-product-line/},\n  doi = {10.5381/jot.2011.10.1.a12},\n  issn = {1660-1769},\n  journal = {Journal of Object Technology},\n  keywords = {AOP CSOM FOP Interpreters MeMyPublication Modularization VirtualMachine myown},\n  month = dec,\n  number = {12},\n  pages = {1-30},\n  pdf = {http://www.stefan-marr.de/downloads/jot11-mhaupt-csompl-a-virtual-machine-product-line.pdf},\n  series = {JoT},\n  title = {CSOM/PL: A Virtual Machine Product Line},\n  url = {http://www.stefan-marr.de/2011/12/csompl-a-virtual-machine-product-line/},\n  volume = {10},\n  year = {2011},\n  month_numeric = {12}\n}\n"}, {"author"=>"Stefan Marr, Mattias De Wael, Michael Haupt, Theo D'Hondt", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"De Wael"}, {"first"=>"M.", "last"=>"Haupt"}, {"first"=>"T.", "last"=>"D'Hondt"}], "abstract"=>"While parallel programming for very regular problems has been used in the\r\nscientific community by non-computer-scientists successfully for a few decades\r\nnow, concurrent programming and solving irregular problems remains hard.\r\nFurthermore, we shift from few expert system programmers mastering concurrency\r\nfor a constrained set of problems to mainstream application developers being\r\nrequired to master concurrency for a wide variety of problems.\r\n\r\nConsequently, high-level language virtual machine (VM) research faces\r\ninteresting questions. What are processor design changes that have an impact\r\non the abstractions provided by VMs to provide platform independence? How can\r\napplication programmers' diverse needs be facilitated to solve concurrent\r\nprogramming problems?\r\n\r\nWe argue that VMs will need to be ready for a wide range of different\r\nconcurrency models that allow solving concurrency problems with appropriate\r\nabstractions. Furthermore, they need to abstract from heterogeneous processor\r\narchitectures, varying performance characteristics, need to account for memory\r\naccess cost and inter-core communication mechanisms but should only expose\r\nthe minimal useful set of notions like locality, explicit communication, and\r\nadaptable scheduling to maintain their abstracting nature.\r\n\r\nEventually, language designers need to be enabled to guarantee properties\r\nlike encapsulation, scheduling guarantees, and immutability also when an\r\ninteraction between different problem-specific concurrency abstractions is\r\nrequired.", "title"=>"Which Problems Does a Multi-Language Virtual Machine Need to Solve in the Multicore/Manycore Era?", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2011", "blog"=>"http://stefan-marr.de/2011/09/which-problems-does-a-multi-language-virtual-machine-need-to-solve-in-the-multicoremanycore-era/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 5th Workshop on Virtual Machines and Intermediate Languages", "interhash"=>"a4cd5f8252cc120bc766688434d535fa", "publisher"=>"ACM", "series"=>"VMIL '11", "series_venue"=>"VMIL", "school"=>"", "doi"=>"10.1145/2095050.2095104", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/vmil11-smarr-et-al-which-problems-does-a-multi-language-virtual-machine-need-to-solve-in-the-multicore-manycore-era.pdf", "pages"=>"341&ndash;348", "publication_date"=>"oct 2011", "bibtex"=>"@inproceedings{VMIL11,\n  abstract = {While parallel programming for very regular problems has been used in the\r\n  scientific community by non-computer-scientists successfully for a few decades\r\n  now, concurrent programming and solving irregular problems remains hard.\r\n  Furthermore, we shift from few expert system programmers mastering concurrency\r\n  for a constrained set of problems to mainstream application developers being\r\n  required to master concurrency for a wide variety of problems.\r\n  \r\n  Consequently, high-level language virtual machine (VM) research faces\r\n  interesting questions. What are processor design changes that have an impact\r\n  on the abstractions provided by VMs to provide platform independence? How can\r\n  application programmers' diverse needs be facilitated to solve concurrent\r\n  programming problems?\r\n  \r\n  We argue that VMs will need to be ready for a wide range of different\r\n  concurrency models that allow solving concurrency problems with appropriate\r\n  abstractions. Furthermore, they need to abstract from heterogeneous processor\r\n  architectures, varying performance characteristics, need to account for memory\r\n  access cost and inter-core communication mechanisms but should only expose\r\n  the minimal useful set of notions like locality, explicit communication, and\r\n  adaptable scheduling to maintain their abstracting nature.\r\n  \r\n  Eventually, language designers need to be enabled to guarantee properties\r\n  like encapsulation, scheduling guarantees, and immutability also when an\r\n  interaction between different problem-specific concurrency abstractions is\r\n  required.},\n  acmid = {2095104},\n  author = {Marr, Stefan and De Wael, Mattias and Haupt, Michael and D'Hondt, Theo},\n  blog = {http://stefan-marr.de/2011/09/which-problems-does-a-multi-language-virtual-machine-need-to-solve-in-the-multicoremanycore-era/},\n  booktitle = {Proceedings of the 5th Workshop on Virtual Machines and Intermediate Languages},\n  doi = {10.1145/2095050.2095104},\n  isbn = {978-1-4503-1183-0},\n  keywords = {Concurrency Encapsulation ManyCore MeMyPublication MultiCore PositionPaper Scheduling Survey VMIL VMs myown},\n  location = {Portland, Oregon, USA},\n  month = oct,\n  numpages = {8},\n  pages = {341--348},\n  pdf = {http://www.stefan-marr.de/downloads/vmil11-smarr-et-al-which-problems-does-a-multi-language-virtual-machine-need-to-solve-in-the-multicore-manycore-era.pdf},\n  publisher = {ACM},\n  series = {VMIL '11},\n  title = {Which Problems Does a Multi-Language Virtual Machine Need to Solve in the Multicore/Manycore Era?},\n  url = {http://www.stefan-marr.de/2011/09/which-problems-does-a-multi-language-virtual-machine-need-to-solve-in-the-multicoremanycore-era/},\n  year = {2011},\n  month_numeric = {10}\n}\n"}, {"author"=>"Michael Haupt, Stefan Marr, Robert Hirschfeld", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"Haupt"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"R.", "last"=>"Hirschfeld"}], "abstract"=>"CSOM/PL is a software product line (SPL) derived from applying\r\nmulti-dimensional separation of concerns (MDSOC) techniques to the\r\ndomain of high-level language virtual machine (VM) implementations.\r\nFor CSOM/PL, we modularised CSOM, a Smalltalk VM implemented\r\nin C, using VMADL (virtual machine architecture description language).\r\nSeveral features of the original CSOM were encapsulated in VMADL\r\nmodules and composed in various combinations. In an evaluation of\r\nour approach, we show that applying MDSOC and SPL principles to a\r\ndomain as complex as that of VMs is not only feasible but beneﬁcial,\r\nas it improves understandability, maintainability, and conﬁgurability of\r\nVM implementations without harming performance.", "title"=>"CSOM/PL: A Virtual Machine Product Line*", "bibtype"=>"techreport", "type"=>"", "journal"=>"", "year"=>"2011", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"b739ed923a0c65e0a687575c5ae724b3", "publisher"=>"Universitätsverlag Potsdam", "series"=>"HPI TR", "series_venue"=>"HPI TR", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"48", "pdf"=>"", "pages"=>"26", "publication_date"=>"18 apr 2011", "bibtex"=>"@techreport{CSOMPL_TR,\n  abstract = {CSOM/PL is a software product line (SPL) derived from applying\r\n  multi-dimensional separation of concerns (MDSOC) techniques to the\r\n  domain of high-level language virtual machine (VM) implementations.\r\n  For CSOM/PL, we modularised CSOM, a Smalltalk VM implemented\r\n  in C, using VMADL (virtual machine architecture description language).\r\n  Several features of the original CSOM were encapsulated in VMADL\r\n  modules and composed in various combinations. In an evaluation of\r\n  our approach, we show that applying MDSOC and SPL principles to a\r\n  domain as complex as that of VMs is not only feasible but beneﬁcial,\r\n  as it improves understandability, maintainability, and conﬁgurability of\r\n  VM implementations without harming performance.},\n  address = {Am Neuen Palais 10, 14469 Potsdam},\n  author = {Haupt, Michael and Marr, Stefan and Hirschfeld, Robert},\n  day = {18},\n  institution = {Hasso Plattner Institute },\n  keywords = {AOP Architecture ArchitectureLanguage CSOM MasterThesis MeMyPublication Modularization Productline VirtualMachine aspect-oriented myown services},\n  month = apr,\n  number = {48},\n  pages = {26},\n  publisher = {Universitätsverlag Potsdam},\n  series = {HPI TR},\n  title = {CSOM/PL: A Virtual Machine Product Line*},\n  url = {http://www.amazon.de/CSOM-PL-virtual-machine-product/dp/3869561343},\n  year = {2011},\n  month_numeric = {4}\n}\n"}, {"author"=>"Tom Van Cutsem, Stefan Marr, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"T.", "last"=>"Van Cutsem"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"This paper argues in favour of a language-oriented approach to teach the principles of concurrency to graduate students. Over the past years, the popularity of programming lan- guages that promote a functional programming style has steadily grown. We want to promote the use of such lan- guages as the appropriate basic tools to deal with the “mul- ticore revolution”.\r\nWe describe some of these programming languages and highlight two of them: Erlang and Clojure. We use these languages in a new graduate-level course that we will teach starting next academic year. Our goal is not to convince the reader that Erlang and Clojure are the best possible choices among this pool of candidate languages. Rather, our goal is to promote a functional programming style to tackle concurrency issues, and to teach this style in a programming language that makes it easy, straightforward and convenient to use that style.\r\nWe do not want to get bogged down in a discussion on the usefulness or importance of learning new programming languages. For a good summary of the diverse advantages of studying new programming languages, we refer to a recent white paper by the ACM SIGPLAN education board [6].", "title"=>"A Language-oriented Approach to Teaching Concurrency", "bibtype"=>"presentation", "type"=>"", "journal"=>"", "year"=>"2010", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Workshop on Curricula for Concurrency and Parallelism", "interhash"=>"fbe640af05dfdd44636b03c67f3ded79", "publisher"=>"", "series"=>"CCP'10", "series_venue"=>"CCP", "school"=>"", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://soft.vub.ac.be/Publications/2010/vub-tr-soft-10-12.pdf", "pages"=>"3", "publication_date"=>"17 oct 2010", "bibtex"=>"@presentation{MulticoreProgramming,\n  abstract = {This paper argues in favour of a language-oriented approach to teach the principles of concurrency to graduate students. Over the past years, the popularity of programming lan- guages that promote a functional programming style has steadily grown. We want to promote the use of such lan- guages as the appropriate basic tools to deal with the “mul- ticore revolution”.\r\n  We describe some of these programming languages and highlight two of them: Erlang and Clojure. We use these languages in a new graduate-level course that we will teach starting next academic year. Our goal is not to convince the reader that Erlang and Clojure are the best possible choices among this pool of candidate languages. Rather, our goal is to promote a functional programming style to tackle concurrency issues, and to teach this style in a programming language that makes it easy, straightforward and convenient to use that style.\r\n  We do not want to get bogged down in a discussion on the usefulness or importance of learning new programming languages. For a good summary of the diverse advantages of studying new programming languages, we refer to a recent white paper by the ACM SIGPLAN education board [6].},\n  author = {Van Cutsem, Tom and Marr, Stefan and De Meuter, Wolfgang},\n  booktitle = {Workshop on Curricula for Concurrency and Parallelism},\n  day = {17},\n  keywords = {MeMyPublication clojure concurrency course erlang immutability myown parallelism teaching},\n  month = oct,\n  pages = {3},\n  pdf = {http://soft.vub.ac.be/Publications/2010/vub-tr-soft-10-12.pdf},\n  series = {CCP'10},\n  title = {A Language-oriented Approach to Teaching Concurrency},\n  url = {http://soft.vub.ac.be/Publications/2010/vub-tr-soft-10-12.pdf},\n  year = {2010},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}], "abstract"=>"We propose to search for common abstractions for different concurrency models to enable high-level language virtual machines to support a wide range of different concurrency models. This would enable domain-specific solutions for the concurrency problem. Furthermore, advanced knowledge about concurrency in the VM model will most likely lead to better implementation opportunities on top of the different upcoming many-core architectures. The idea is to investigate the concepts of encapsulation and locality to this end. Thus, we are going to experiment with different language abstractions for concurrency on top of a virtual machine, which supports encapsulation and locality, to see how language designers could benefit, and how virtual machines could optimize programs using these concepts.", "title"=>"Encapsulation And Locality: A Foundation for Concurrency Support in Multi-Language Virtual Machines?", "bibtype"=>"inproceedings", "type"=>"Doctoral Symposium", "journal"=>"", "year"=>"2010", "blog"=>"http://stefan-marr.de/2010/07/doctoral-symposium-at-splash-2010/", "html"=>"", "appendix"=>"", "booktitle"=>"SPLASH '10: Proceedings of the ACM International Conference Companion on Object Oriented Programming Systems Languages and Applications Companion", "interhash"=>"0a2db296019a5c54a8711b76dd6fd06e", "publisher"=>"ACM", "series"=>"SPLASH DocSymp", "series_venue"=>"SPLASH DocSymp", "school"=>"", "doi"=>"10.1145/1869542.1869583", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/docsymp-smarr.pdf", "pages"=>"221&ndash;222", "publication_date"=>"17-21 oct 2010", "bibtex"=>"@inproceedings{SplashDocSymp2010,\n  abstract = {We propose to search for common abstractions for different concurrency models to enable high-level language virtual machines to support a wide range of different concurrency models. This would enable domain-specific solutions for the concurrency problem. Furthermore, advanced knowledge about concurrency in the VM model will most likely lead to better implementation opportunities on top of the different upcoming many-core architectures. The idea is to investigate the concepts of encapsulation and locality to this end. Thus, we are going to experiment with different language abstractions for concurrency on top of a virtual machine, which supports encapsulation and locality, to see how language designers could benefit, and how virtual machines could optimize programs using these concepts.},\n  address = {New York, NY, USA},\n  author = {Marr, Stefan},\n  blog = {http://stefan-marr.de/2010/07/doctoral-symposium-at-splash-2010/},\n  booktitle = {SPLASH '10: Proceedings of the ACM International Conference Companion on Object Oriented Programming Systems Languages and Applications Companion},\n  day = {17-21},\n  doi = {10.1145/1869542.1869583},\n  isbn = {978-1-4503-0240-1},\n  keywords = {Abstraction Concurrency ManyCore MeMyPublication Proposal VM myown},\n  location = {Reno/Tahoe, Nevada, USA},\n  month = oct,\n  pages = {221--222},\n  pdf = {http://www.stefan-marr.de/downloads/docsymp-smarr.pdf},\n  publisher = {ACM},\n  series = {SPLASH DocSymp},\n  title = {Encapsulation And Locality: A Foundation for Concurrency Support in Multi-Language Virtual Machines?},\n  type = {Doctoral Symposium},\n  url = {http://www.stefan-marr.de/2010/07/doctoral-symposium-at-splash-2010/},\n  year = {2010},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr, Theo D'Hondt", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"T.", "last"=>"D'Hondt"}], "abstract"=>"We propose to search for common abstractions for concurrency models to enable multi-language virtual machines to support a wide range of them. This would enable domain-specific solutions for concurrency problems. Furthermore, such an abstraction could improve portability of virtual machines to the vastly different upcoming many-core architectures.", "title"=>"Many-Core Virtual Machines: Decoupling Abstract from Concrete Concurrency", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2010", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"SPLASH '10: Companion of the ACM International Conference on Object Oriented Programming Systems Languages and Applications", "interhash"=>"dd6e347dcdbd2585fd2fb1b279369252", "publisher"=>"", "series"=>"SPLASH Poster", "series_venue"=>"SPLASH Poster", "school"=>"", "doi"=>"10.1145/1869542.1869593", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/docsymp-smarr.pdf", "pages"=>"239&ndash;240", "publication_date"=>"oct 2010", "bibtex"=>"@inproceedings{SplashPoster2010,\n  abstract = {We propose to search for common abstractions for concurrency models to enable multi-language virtual machines to support a wide range of them. This would enable domain-specific solutions for concurrency problems. Furthermore, such an abstraction could improve portability of virtual machines to the vastly different upcoming many-core architectures.},\n  author = {Marr, Stefan and D'Hondt, Theo},\n  booktitle = {SPLASH '10: Companion of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},\n  doi = {10.1145/1869542.1869593},\n  isbn = {978-1-4503-0240-1},\n  keywords = {ManyCore MeMyPublication MultiCore Poster SPLASH machines myown virtual},\n  location = {Reno/Tahoe, Nevada, USA},\n  month = oct,\n  note = {(Poster)},\n  pages = {239--240},\n  pdf = {http://www.stefan-marr.de/downloads/docsymp-smarr.pdf},\n  series = {SPLASH Poster},\n  title = {Many-Core Virtual Machines: Decoupling Abstract from Concrete Concurrency},\n  url = {http://www.stefan-marr.de/2010/08/poster-at-splash10/},\n  year = {2010},\n  month_numeric = {10}\n}\n"}, {"author"=>"Stefan Marr, Stijn Verhaegen, Bruno De Fraine, Theo D'Hondt, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"S.", "last"=>"Verhaegen"}, {"first"=>"B.", "last"=>"De Fraine"}, {"first"=>"T.", "last"=>"D'Hondt"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"This paper presents an algorithm and a data structure for scalable dynamic synchronization in\r\nfine-grained parallelism. The algorithm supports the full generality of phasers with\r\ndynamic, two-phase, and point-to-point synchronization. It retains the scalability of \r\nclassical tree barriers, but provides unbounded dynamicity by employing a tailor-made\r\ninsertion tree data structure.\r\n\r\nIt is the first completely documented implementation strategy for a scalable phaser\r\nsynchronization construct. Our evaluation shows that it can be used\r\nas a drop-in replacement for classic barriers without harming performance, despite its additional\r\ncomplexity and potential for performance optimizations.\r\nFurthermore, our approach overcomes performance and scalability limitations\r\nwhich have been present in other phaser proposals.", "title"=>"Insertion Tree Phasers: Efficient and Scalable Barrier Synchronization  for Fine-grained Parallelism", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2010", "blog"=>"http://stefan-marr.de/2010/07/insertion-tree-phasers-efficient-and-scalable-barrier-synchronization-for-fine-grained-parallelism/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 12th IEEE International Conference on High Performance Computing and Communications", "interhash"=>"db46bfb816422a5055237a1b387e3dfe", "publisher"=>"IEEE Computer Society", "series"=>"HPCC'10", "series_venue"=>"HPCC", "school"=>"", "doi"=>"10.1109/HPCC.2010.30", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/hpcc2010-marr-etal-insertion-tree-phasers.pdf", "pages"=>"130&ndash;137", "publication_date"=>"sep 2010", "bibtex"=>"@inproceedings{InsertionTreePhasers,\n  abstract = {This paper presents an algorithm and a data structure for scalable dynamic synchronization in\r\n  fine-grained parallelism. The algorithm supports the full generality of phasers with\r\n  dynamic, two-phase, and point-to-point synchronization. It retains the scalability of \r\n  classical tree barriers, but provides unbounded dynamicity by employing a tailor-made\r\n  insertion tree data structure.\r\n  \r\n  It is the first completely documented implementation strategy for a scalable phaser\r\n  synchronization construct. Our evaluation shows that it can be used\r\n  as a drop-in replacement for classic barriers without harming performance, despite its additional\r\n  complexity and potential for performance optimizations.\r\n  Furthermore, our approach overcomes performance and scalability limitations\r\n  which have been present in other phaser proposals.},\n  author = {Marr, Stefan and Verhaegen, Stijn and De Fraine, Bruno and D'Hondt, Theo and De Meuter, Wolfgang},\n  blog = {http://stefan-marr.de/2010/07/insertion-tree-phasers-efficient-and-scalable-barrier-synchronization-for-fine-grained-parallelism/},\n  booktitle = {Proceedings of the 12th IEEE International Conference on High Performance Computing and Communications},\n  doi = {10.1109/HPCC.2010.30},\n  isbn = {978-0-7695-4214-0},\n  keywords = {Barrier MeMyPublication Phasers X10 algorithm benchmarks clocks evaluation habanero insertionTree myown tree},\n  month = sep,\n  note = {Best Student Paper AwardAcceptance Rate: 19,1% (58/304)},\n  pages = {130-137},\n  pdf = {http://www.stefan-marr.de/downloads/hpcc2010-marr-etal-insertion-tree-phasers.pdf},\n  publisher = {IEEE Computer Society},\n  series = {HPCC'10},\n  title = {Insertion Tree Phasers: Efficient and Scalable Barrier Synchronization  for Fine-grained Parallelism},\n  url = {http://www.stefan-marr.de/2010/07/insertion-tree-phasers-efficient-and-scalable-barrier-synchronization-for-fine-grained-parallelism/},\n  year = {2010},\n  month_numeric = {9}\n}\n"}, {"author"=>"Michael Haupt, Robert Hirschfeld, Tobias Pape, Gregor Gabrysiak, Stefan Marr, Arne Bergmann, Arvid Heise, Matthias Kleine, Robert Krahn", "author_abbr_firstname"=>[{"first"=>"M.", "last"=>"Haupt"}, {"first"=>"R.", "last"=>"Hirschfeld"}, {"first"=>"T.", "last"=>"Pape"}, {"first"=>"G.", "last"=>"Gabrysiak"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"A.", "last"=>"Bergmann"}, {"first"=>"A.", "last"=>"Heise"}, {"first"=>"M.", "last"=>"Kleine"}, {"first"=>"R.", "last"=>"Krahn"}], "abstract"=>"This paper introduces the SOM (Simple Object Machine) family of virtual machine (VM) implementations. Starting from a Java-based implementation, several ports of the VM to different programming languages have been developed and put to successful use in teaching at both undergraduate and graduate levels since 2006. Moreover, the VMs have been used in various research projects. We document the rationale behind each of the SOM VMs and results that have been achieved in teaching and research.", "title"=>"The SOM Family: Virtual Machines for Teaching and Research", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2010", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 15th Annual Conference on Innovation and Technology in Computer Science Education", "interhash"=>"60d5f63bfbb8aad1fddc8fedff16c905", "publisher"=>"ACM Press", "series"=>"ITiCSE'10", "series_venue"=>"ITiCSE", "school"=>"", "doi"=>"10.1145/1822090.1822098", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.hpi.uni-potsdam.de/hirschfeld/publications/media/HauptHirschfeldPapeGabrysiakMarrBergmannHeiseKleineKrahn_2010_TheSomFamily_AcmDL.pdf", "pages"=>"18&ndash;22", "publication_date"=>"26--30 jun 2010", "bibtex"=>"@inproceedings{SOMFamily,\n  abstract = {This paper introduces the SOM (Simple Object Machine) family of virtual machine (VM) implementations. Starting from a Java-based implementation, several ports of the VM to different programming languages have been developed and put to successful use in teaching at both undergraduate and graduate levels since 2006. Moreover, the VMs have been used in various research projects. We document the rationale behind each of the SOM VMs and results that have been achieved in teaching and research.},\n  acceptancerate = {0.51},\n  author = {Haupt, Michael and Hirschfeld, Robert and Pape, Tobias and Gabrysiak, Gregor and Marr, Stefan and Bergmann, Arne and Heise, Arvid and Kleine, Matthias and Krahn, Robert},\n  booktitle = {Proceedings of the 15th Annual Conference on Innovation and Technology in Computer Science Education},\n  day = {26--30},\n  doi = {10.1145/1822090.1822098},\n  isbn = {978-1-60558-729-5},\n  keywords = {CSOM MeMyPublication SOM Teaching VM myown},\n  location = {Bilkent, Ankara, Turkey},\n  month = jun,\n  note = {(acceptance rate 51%)},\n  pages = {18--22},\n  pdf = {http://www.hpi.uni-potsdam.de/hirschfeld/publications/media/HauptHirschfeldPapeGabrysiakMarrBergmannHeiseKleineKrahn_2010_TheSomFamily_AcmDL.pdf},\n  publisher = {ACM Press},\n  series = {ITiCSE'10},\n  title = {The SOM Family: Virtual Machines for Teaching and Research},\n  url = {http://www.hpi.uni-potsdam.de/hirschfeld/publications/media/HauptHirschfeldPapeGabrysiakMarrBergmannHeiseKleineKrahn_2010_TheSomFamily_AcmDL.pdf},\n  year = {2010},\n  month_numeric = {6}\n}\n"}, {"author"=>"Stefan Marr, Michael Haupt, Stijn Timbermont, Bram Adams, Theo D'Hondt, Pascal Costanza, Wolfgang De Meuter", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"Haupt"}, {"first"=>"S.", "last"=>"Timbermont"}, {"first"=>"B.", "last"=>"Adams"}, {"first"=>"T.", "last"=>"D'Hondt"}, {"first"=>"P.", "last"=>"Costanza"}, {"first"=>"W.", "last"=>"De Meuter"}], "abstract"=>"The upcoming many-core architectures require software developers to exploit concurrency to utilize available computational power. Today's high-level language virtual machines (VMs), which are a cornerstone of software development, do not provide sufficient abstraction for concurrency concepts. We analyze concrete and abstract concurrency models and identify the challenges they impose for VMs. To provide sufficient concurrency support in VMs, we propose to integrate concurrency operations into VM instruction sets.\r\n\r\nSince there will always be VMs optimized for special purposes, our goal is to develop a methodology to design instruction sets with concurrency support. Therefore, we also propose a list of trade-offs that have to be investigated to advise the design of such instruction sets. \r\n\r\nAs a first experiment, we implemented one instruction set extension for shared memory and one for non-shared memory concurrency. From our experimental results, we derived a list of requirements for a full-grown experimental environment for further research.", "title"=>"Virtual Machine Support for Many-Core Architectures: Decoupling Abstract From Concrete Concurrency Models", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2010", "blog"=>"http://stefan-marr.de/2010/02/virtual-machine-support-for-many-core-architectures-decoupling-abstract-from-concrete-concurrency-models/", "html"=>"", "appendix"=>"", "booktitle"=>"Second International Workshop on Programming Languages Approaches to Concurrency and Communication-cEntric Software", "interhash"=>"951ffceb7deb0e7a0880a89ac3df470b", "publisher"=>"", "series"=>"PLACES'09 (EPTCS)", "series_venue"=>"PLACES", "school"=>"", "doi"=>"10.4204/EPTCS.17.6", "howpublished"=>"", "number"=>"", "pdf"=>"http://arxiv.org/pdf/1002.0939v1", "pages"=>"63&ndash;77", "publication_date"=>"feb 2010", "bibtex"=>"@inproceedings{places09,\n  abstract = {The upcoming many-core architectures require software developers to exploit concurrency to utilize available computational power. Today's high-level language virtual machines (VMs), which are a cornerstone of software development, do not provide sufficient abstraction for concurrency concepts. We analyze concrete and abstract concurrency models and identify the challenges they impose for VMs. To provide sufficient concurrency support in VMs, we propose to integrate concurrency operations into VM instruction sets.\r\n  \r\n  Since there will always be VMs optimized for special purposes, our goal is to develop a methodology to design instruction sets with concurrency support. Therefore, we also propose a list of trade-offs that have to be investigated to advise the design of such instruction sets. \r\n  \r\n  As a first experiment, we implemented one instruction set extension for shared memory and one for non-shared memory concurrency. From our experimental results, we derived a list of requirements for a full-grown experimental environment for further research.},\n  author = {Marr, Stefan and Haupt, Michael and Timbermont, Stijn and Adams, Bram and D'Hondt, Theo and Costanza, Pascal and De Meuter, Wolfgang},\n  blog = {http://stefan-marr.de/2010/02/virtual-machine-support-for-many-core-architectures-decoupling-abstract-from-concrete-concurrency-models/},\n  booktitle = {Second International Workshop on Programming Languages Approaches to Concurrency and Communication-cEntric Software},\n  doi = {10.4204/EPTCS.17.6},\n  keywords = {MeMyPublication myown},\n  month = feb,\n  pages = {63-77},\n  pdf = {http://arxiv.org/pdf/1002.0939v1},\n  series = {PLACES'09 (EPTCS)},\n  title = {Virtual Machine Support for Many-Core Architectures: Decoupling Abstract From Concrete Concurrency Models},\n  volume = {17},\n  year = {2010},\n  month_numeric = {2}\n}\n"}, {"author"=>"Stefan Marr, Michael Haupt, Theo D'Hondt", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"Haupt"}, {"first"=>"T.", "last"=>"D'Hondt"}], "abstract"=>"Today's major high-level language virtual machines (VMs) are becoming successful in being multi-language execution platforms, hosting a wide range of languages. With the transition from few-core to many-core processors, we argue that VMs will also have to abstract from concrete concurrency models at the hardware level, to be able to support a wide range of abstract concurrency models on a language\r\nlevel. To overcome the lack of sufficient abstractions for concurrency concepts in VMs, we proposed earlier to extend VM intermediate languages by special concurrency constructs.\r\n\r\nAs a first step towards this goal, we try to fill a gap in the current literature and survey the intermediate language design of VMs. Our goal is to identify currently used techniques and principles as well as to gain an overview over the available concurrency related features in intermediate languages.\r\n\r\nAnother aspect of interest is the influence of the particular target language, for which the VM is originally intended, on the intermediate language.", "title"=>"Intermediate Language Design of High-level Language Virtual Machines: Towards Comprehensive Concurrency Support", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2009", "blog"=>"http://www.stefan-marr.de/2010/02/intermediate-language-design-of-high-level-language-virtual-machines-towards-comprehensive-concurrency-support/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the 3rd Workshop on Virtual Machines and Intermediate Languages", "interhash"=>"2b7468ff600c441ea322f28dfdac938e", "publisher"=>"ACM", "series"=>"VMIL'09", "series_venue"=>"VMIL", "school"=>"", "doi"=>"10.1145/1711506.1711509", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/vmil09-smarr.pdf", "pages"=>"3:1&ndash;3:2", "publication_date"=>"oct 2009", "bibtex"=>"@inproceedings{VMIL09,\n  abstract = {Today's major high-level language virtual machines (VMs) are becoming successful in being multi-language execution platforms, hosting a wide range of languages. With the transition from few-core to many-core processors, we argue that VMs will also have to abstract from concrete concurrency models at the hardware level, to be able to support a wide range of abstract concurrency models on a language\r\n  level. To overcome the lack of sufficient abstractions for concurrency concepts in VMs, we proposed earlier to extend VM intermediate languages by special concurrency constructs.\r\n  \r\n  As a first step towards this goal, we try to fill a gap in the current literature and survey the intermediate language design of VMs. Our goal is to identify currently used techniques and principles as well as to gain an overview over the available concurrency related features in intermediate languages.\r\n  \r\n  Another aspect of interest is the influence of the particular target language, for which the VM is originally intended, on the intermediate language.},\n  address = {New York, NY, USA},\n  author = {Marr, Stefan and Haupt, Michael and D'Hondt, Theo},\n  blog = {http://www.stefan-marr.de/2010/02/intermediate-language-design-of-high-level-language-virtual-machines-towards-comprehensive-concurrency-support/},\n  booktitle = {Proceedings of the 3rd Workshop on Virtual Machines and Intermediate Languages},\n  doi = {10.1145/1711506.1711509},\n  isbn = {978-1-60558-874-2},\n  keywords = {Bytecode Concurrency Design InstructionSet IntermediateLanguage Language Machines MeMyPublication Survey Virtual myown},\n  month = oct,\n  note = {(extended abstract)},\n  pages = {3:1--3:2},\n  pdf = {http://www.stefan-marr.de/downloads/vmil09-smarr.pdf},\n  publisher = {ACM},\n  series = {VMIL'09},\n  title = {Intermediate Language Design of High-level Language Virtual Machines: Towards Comprehensive Concurrency Support},\n  url = {http://www.stefan-marr.de/2010/02/intermediate-language-design-of-high-level-language-virtual-machines-towards-comprehensive-concurrency-support/},\n  year = {2009},\n  month_numeric = {10}\n}\n"}, {"author"=>"Hans Schippers, Tom Van Cutsem, Stefan Marr, Michael Haupt, Robert Hirschfeld", "author_abbr_firstname"=>[{"first"=>"H.", "last"=>"Schippers"}, {"first"=>"T.", "last"=>"Van Cutsem"}, {"first"=>"S.", "last"=>"Marr"}, {"first"=>"M.", "last"=>"Haupt"}, {"first"=>"R.", "last"=>"Hirschfeld"}], "abstract"=>"In this position paper we propose to extend an existing delegation-based machine model with concurrency primitives. The original machine model which is built on the concepts of objects, messages, and delegation, provides support for languages enabling multi-dimensional separation of concerns (MDSOC). We propose to extend this model with an actor-based concurrency model, allowing for both true parallelism as well as lightweight concurrency primitives such as coroutines. In order to demonstrate its expressiveness, we informally describe how three high-level languages supporting different concurrency models can be mapped onto our extended machine model. We also provide an outlook on the extended model's potential to support concurrency-related MDSOC features.", "title"=>"Towards an Actor-based Concurrent Machine Model", "bibtype"=>"inproceedings", "type"=>"", "journal"=>"", "year"=>"2009", "blog"=>"http://stefan-marr.de/2010/02/towards-an-actor-based-concurrent-machine-model/", "html"=>"", "appendix"=>"", "booktitle"=>"Proceedings of the Fourth Workshop on the Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS)", "interhash"=>"6b2514a55e250ff8f88ac54a52b71323", "publisher"=>"ACM", "series"=>"ICOOOLPS'09", "series_venue"=>"ICOOOLPS", "school"=>"", "doi"=>"10.1145/1565824.1565825", "howpublished"=>"", "number"=>"", "pdf"=>"http://www.stefan-marr.de/downloads/icooolps09-schippers.pdf", "pages"=>"4&ndash;9", "publication_date"=>"6 jul 2009", "bibtex"=>"@inproceedings{TowardsACMM,\n  abstract = {In this position paper we propose to extend an existing delegation-based machine model with concurrency primitives. The original machine model which is built on the concepts of objects, messages, and delegation, provides support for languages enabling multi-dimensional separation of concerns (MDSOC). We propose to extend this model with an actor-based concurrency model, allowing for both true parallelism as well as lightweight concurrency primitives such as coroutines. In order to demonstrate its expressiveness, we informally describe how three high-level languages supporting different concurrency models can be mapped onto our extended machine model. We also provide an outlook on the extended model's potential to support concurrency-related MDSOC features.},\n  author = {Schippers, Hans and Van Cutsem, Tom and Marr, Stefan and Haupt, Michael and Hirschfeld, Robert},\n  blog = {http://stefan-marr.de/2010/02/towards-an-actor-based-concurrent-machine-model/},\n  booktitle = {Proceedings of the Fourth Workshop on the Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS)},\n  day = {6},\n  doi = {10.1145/1565824.1565825},\n  isbn = {978-1-60558-541-3},\n  keywords = {Actors Concurrency Io Java MDSOC MachineModel MeMyPublication Salsa VM myown},\n  location = {Genova, Italy},\n  month = jul,\n  pages = {4--9},\n  pdf = {http://www.stefan-marr.de/downloads/icooolps09-schippers.pdf},\n  publisher = {ACM},\n  series = {ICOOOLPS'09},\n  title = {Towards an Actor-based Concurrent Machine Model},\n  url = {http://www.stefan-marr.de/2010/02/towards-an-actor-based-concurrent-machine-model/},\n  year = {2009},\n  month_numeric = {7}\n}\n"}, {"author"=>"Stefan Marr", "author_abbr_firstname"=>[{"first"=>"S.", "last"=>"Marr"}], "title"=>"Modularisierung Virtueller Maschinen", "bibtype"=>"mastersthesis", "type"=>"", "journal"=>"", "year"=>"2008", "blog"=>"", "html"=>"", "appendix"=>"", "booktitle"=>"", "interhash"=>"5e1e1e699ff09e4ff0e9a15937aad116", "publisher"=>"", "series"=>"Master Thesis", "series_venue"=>"Master Thesis", "school"=>"Hasso Plattner Institute", "doi"=>"", "howpublished"=>"", "number"=>"", "pdf"=>"http://stefan-marr.de/downloads/Masterarbeit-Modularisierung-virtueller-Maschinen.pdf", "pages"=>nil, "publication_date"=>"sep 2008", "bibtex"=>"@mastersthesis{MAThesis,\n  address = {Potsdam, Germany},\n  author = {Marr, Stefan},\n  keywords = {Me:MastersThesis MeMyPublication myown},\n  month = sep,\n  pdf = {http://stefan-marr.de/downloads/Masterarbeit-Modularisierung-virtueller-Maschinen.pdf},\n  school = {Hasso Plattner Institute},\n  series = {Master Thesis},\n  title = {Modularisierung Virtueller Maschinen},\n  url = {http://www.stefan-marr.de/2008/10/i-am-done-eventually/},\n  year = {2008},\n  month_numeric = {9}\n}\n"}]
end
